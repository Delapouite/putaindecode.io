<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Fri, 11 Dec 2015 07:05:24 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[ES6, ES2015 : itérateurs et générateurs]]></title><description><![CDATA[<h1 id="it-rateurs-et-g-n-rateurs"><a class="markdownIt-Anchor" href="#it-rateurs-et-g-n-rateurs">#</a> Itérateurs et générateurs</h1>
<p>Un gros morceau aujourd’hui : les itérateurs et les fonctions qui les génèrent,
appelées “générateurs”.
ES6/2015 apporte énormément de “sucres syntaxiques”, même s’ils sont
terriblement pratiques. Les valeurs par défaut, l’affectation par
déstructuration, les fonctions flêchées…
Tout ça n’apporte pas de réelle nouvelle fonctionnalité.
C’est un peu différent pour les générateurs qui vont permettre de prendre le
contrôle sur l’éxécution d’une fonction depuis l’extérieur.</p>
<h2 id="fonction-en-pause"><a class="markdownIt-Anchor" href="#fonction-en-pause">#</a> Fonction “en pause”</h2>
<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par
l’astérisque n’est jamais exécutée directement, à la place, elle retourne un
<em>itérateur</em>. Un générateur est donc capable de s’interrompre (d’ailleurs, il
l’est par défaut).
Il est également capable de reprendre là où il s’était arrêté :
l’itérateur retourné est un objet exposant une méthode  <code>next</code> qui
lorsqu’elle est appelée demande au générateur de reprendre là où il en était.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// L'exécution de la fonction est interrompue en attente d'être "débloquée"</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// L'éxécution reprend et on affiche "World"</span></code></pre>
<p>Notez qu’il ne s’agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,
son traitement sera repris plus tard, pendant ce temps l’<em>event-loop</em> continue
sa petite vie.</p>
<h2 id="reprise-du-traitement-et-mission-de-valeur-avec-yield"><a class="markdownIt-Anchor" href="#reprise-du-traitement-et-mission-de-valeur-avec-yield">#</a> Reprise du traitement et émission de valeur avec <code>yield</code></h2>
<p>La méthode <code>next()</code> de l’itérateur retourne un objet possédant les propriétés
suivantes :</p>
<ul>
<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>
<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>
</ul>
<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir
une valeur et de remettre en pause l’exécution de la fonction. Le principe étant
qu’on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement
<code>return</code>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la
propriété <code>value</code> de la dernière itération.</p>
<h3 id="use-case-listes-infinies"><a class="markdownIt-Anchor" href="#use-case-listes-infinies">#</a> <em>Use case</em> : listes infinies</h3>
<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de
longueur non définie à l’avance. On peut parcourir une suite dont on ne sait pas
à l’avance <em>combien</em> d’éléments on veut, par exemple récupérer tous les éléments
de la suite de Fibonacci inférieurs à 100 :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note : l’opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>
<h2 id="passage-de-valeur-au-g-n-rateur"><a class="markdownIt-Anchor" href="#passage-de-valeur-au-g-n-rateur">#</a> Passage de valeur au générateur</h2>
<p>On a vu que <code>yield</code> permettait d’émettre une valeur depuis le générateur vers
le code contrôleur. Mais le sens inverse est également possible : la méthode
<code>next</code> de l’itérateur accepte une valeur en paramètre, qui sera alors
retournée par l’appel correspondant à <code>yield</code>. Exemple :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Le premier appel à next() permet de "démarrer" le générateur</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// la valeur de la première itération sera undefined</span>
  <span class="hljs-comment">// x = le paramètre du second appel à next()</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// valeur de la seconde itération : x + 1</span>
  <span class="hljs-comment">// y = paramètre du troisième appel à next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// valeur de la troisième itération : y</span>
  <span class="hljs-comment">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le générateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>
n’importe quel type de donnée : une fonction, un objet, un autre itérateur… Les
possibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>
<h3 id="use-case-coroutines"><a class="markdownIt-Anchor" href="#use-case-coroutines">#</a> <em>Use case</em> : coroutines</h3>
<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à
<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est
libre d’appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>
<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et
quand elles peuvent reprendre leur traitement. Et si… notre générateur émettait
des promesses ? Histoire d’expliquer à son code contrôleur <em>quand</em> il est sûr de
reprendre le traitement. Et si ce code contrôleur, voyant qu’il récupère une
promesse, attendait que cette dernière soit résolue pour transmettre au
générateur en retour la valeur résolue ? Dans ce cas le générateur pourrait
disposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de
traitements asynchrones :</p>
<pre><code class="language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request…"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work…"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save…"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request… Work… Save… OK.</span></code></pre>
<p>Ne serait-ce pas merveilleux ? C’est le <em><em>use case</em></em> le plus intéressant pour
nous au quotidien, et c’est assez simple en fait :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// en pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// Le générateur a return'é, fin du game</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// c'est un générateur de promesse, dont on attend la résolution ici</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// La promesse est résolue, on peut repasser sa valeur au générateur</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// cette valeur est return'ée par</span>
      <span class="hljs-comment">// le même "yield" qui a émis la promesse, ça tombe bien :)</span>

      <span class="hljs-comment">// Puis on relance notre boucle, et on continue récursivement</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next() <span class="hljs-comment">// exécution reprise jusqu'au prochain "yield"</span>
  <span class="hljs-comment">// le générateur est remis en pause jusqu'au prochain appel à "iter.next"</span>

  <span class="hljs-comment">// Première itération de la boucle</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a class="markdownIt-Anchor" href="#more-more-more">#</a> More! more! more!</h2>
<h3 id="gestion-d-erreur"><a class="markdownIt-Anchor" href="#gestion-d-erreur">#</a> Gestion d’erreur</h3>
<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux
directions. Le générateur peut <code>throw</code> vers le code contrôleur (le code est
synchrone) :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>Mais le code contrôleur peut également émettre une erreur vers le générateur
avec la méthode <code>throw</code> de l’itérateur :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// affiche "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>
l’exécution du générateur, qui va alors jusqu’au premier <code>yield</code>, évalue
l’expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en
pause. C’est au second <code>yield</code> seulement que l’exécution reprend <strong>à partir de
<code>yield 1</code></strong>. C’est une partie que je trouve contre-intuitive et que j’ai eu du
mal à assimiler.</p>
<h3 id="d-l-gation"><a class="markdownIt-Anchor" href="#d-l-gation">#</a> Délégation</h3>
<p>L’opérateur <code>yield*</code> permet d’émettre les valeurs d’un autre itérateur, par
exemple :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>Cela fonction bien sûr avec tous
<a href="/fr/articles/js/es2015/iterators/">les <em>itérables</em></a> :
<code>yield * [1, 2, 3]</code> est valide par exemple.</p>
<h3 id="retour-anticip"><a class="markdownIt-Anchor" href="#retour-anticip">#</a> Retour anticipé</h3>
<p>Il est possible de terminer le traitement d’un générateur depuis le code
contrôleur avec la méthode <code>return</code> de l’itérateur. Tout se passera comme si
le générateur se terminait immédiatement avec la valeur de retour fournie.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Un habituel petit coup d’œil sur <a href="https://kangax.github.io/compat-table/es6/#test-generators">la compatibilité</a> :</p>
<ul>
<li>Les navigateurs modernes (donc pas IE)</li>
<li>IE Edge ≥ 13</li>
<li>Niveau polyfill, c’est vers Babel ou Traceur qu’il faudra se tourner</li>
</ul>
<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent
d’inverser la responsabilité : c’est le code appelant qui prend le pouvoir sur
la façon dont va s’exécuter la fonction appelée. Ils représentent le premier pas
vers d’autres concepts qui bouleverseront probablement votre façon de coder dans
quelques mois/années : fonctions asynchrones, observables… prennent leurs
racines dans les générateurs. Les comprendre permettra de mieux appréhender de
futures fonctionnalités.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : le protocole d'itération]]></title><description><![CDATA[<p>Imaginez un concept si important que si vous l’enleviez du langage, il faudrait
en conséquence enlever le spread, le destructuring, les générateurs, le for…of
et bien d’autres. Ce concept, introduit dans l’ES6, est en fait un protocole :
le protocole d’itération.</p>
<p>Le principe est de définir une convention dans le langage, qui permet de
standardiser la façon dont des sources de données peuvent être traversées.</p>
<p>Première bonne nouvelle, ce protocole est assez simple à comprendre et se base
sur 2 “interfaces” (oui les guillemets c’est pour dire qu’on ne parle pas
d’interface au sens technique, puisqu’elles n’existent pas en JS).</p>
<p>La première interface, appelée <strong>Iterator</strong> permet à un objet de produire des
valeurs en séquence. Un objet est un Iterator lorsqu’il implémente une
function <code>next()</code> qui retourne un objet avec 2 propriétés :</p>
<ul>
<li><code>value</code>: la valeur courante lors de l’itération</li>
<li><code>done</code> : un booléen qui indique si on a atteint la fin de l’itération ou non</li>
</ul>
<p>Les appels successifs à la méthode <code>next()</code> d’un Iterator permettent donc de
traverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator
retourné par un Array qui contiendrait 2 valeurs (“a” et “b”) :</p>
<pre><code class="language-js">iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>Mais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)
Ça tombe bien, c’est le rôle de la seconde interface, appelée <strong>Iterable</strong>. Un
objet est Iterable s’il implémente une méthode particulière qui va retourner
l’Iterator. Cette méthode particulière (appelée <em>@@iterator</em> dans la
spécification) doit être définie en utilisant le symbole <code>[Symbol.iterator]</code>.
(Les symboles seront expliqués dans un prochain article, pas de panique).</p>
<p>En reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array :</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">var</span> iteratorArray = arr[<span class="hljs-built_in">Symbol</span>.iterator]();
iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next();
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>L’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array.
Il n’est pas très utile en soi, en voici donc un autre qui va permettre de
boucler sur les valeurs et les afficher :</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">var</span> iterator = arr[<span class="hljs-built_in">Symbol</span>.iterator]();

<span class="hljs-keyword">var</span> result = iterator.next();
<span class="hljs-keyword">while</span> (!result.done) {
  <span class="hljs-built_in">console</span>.log(result.value);
  result = iterator.next();
}
<span class="hljs-comment">// 'a'</span>
<span class="hljs-comment">// 'b'</span></code></pre>
<p>De manière générale, quand un objet qui implémente le protocole d’itération est
traversé, sa méthode <em>@@iterator</em> est appelée (une seule fois donc) et l’Iterator
retourné est utilisé pour boucler sur ses valeurs.</p>
<h1 id="consommateurs-d-iterable"><a class="markdownIt-Anchor" href="#consommateurs-d-iterable">#</a> Consommateurs d’Iterable</h1>
<p>La deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent avantage de ce protocole :</p>
<ul>
<li>Certaines syntaxes s’attendent à recevoir des Iterable</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];

<span class="hljs-comment">// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of »</span>
<span class="hljs-comment">// qui permet de boucler sur les valeurs des Iterable.</span>
<span class="hljs-keyword">for</span> (val <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(val);
}

<span class="hljs-comment">// Le spread qui permet d'insérer facilement des valeurs dans un Array</span>
<span class="hljs-comment">// utilise également des Iterable</span>
[<span class="hljs-string">'0'</span>, ...arr, <span class="hljs-string">'1'</span>] <span class="hljs-comment">// 0, a, b, 1</span>

<span class="hljs-comment">// yield nécessite également des Iterable</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">yield</span>* arr;
}
gen().next(); <span class="hljs-comment">// { value:"a", done:false }</span>

<span class="hljs-comment">// Le destructuring avec le pattern Array</span>
<span class="hljs-keyword">let</span> [x, y] = arr; <span class="hljs-comment">// x = 'a',  y = "b"</span></code></pre>
<ul>
<li>Des API acceptent également des Iterable</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>];

<span class="hljs-comment">// Certains constructeurs acceptent des Iterable</span>

<span class="hljs-comment">// Set et Weakset</span>
<span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);
set.has(<span class="hljs-string">"b"</span>) <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Map et WeakMap</span>
<span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr.entries()); <span class="hljs-comment">// Attention, le constructeur attend un ensemble [clé, valeur]</span>
map.get(<span class="hljs-number">0</span>) <span class="hljs-comment">// 'a'</span>


<span class="hljs-comment">// Ou encore les API suivants :</span>

<span class="hljs-built_in">Array</span>.from(iterable); <span class="hljs-comment">// transforme n'importe quel Iterable en Array.</span>
<span class="hljs-built_in">Promise</span>.all(iterableCollectionDePromises); <span class="hljs-comment">// n'importe quel Iterable qui contient un ensemble de Promises</span>
<span class="hljs-built_in">Promise</span>.race(iterableCollectionDePromises); <span class="hljs-comment">// idem</span></code></pre>
<h1 id="built-in-iterable"><a class="markdownIt-Anchor" href="#built-in-iterable">#</a> Built-in Iterable</h1>
<p>Troisième bonne nouvelle, plusieurs objets du langage implémentent déjà ce protocole :</p>
<pre><code class="language-js"><span class="hljs-comment">// évidemment les Array</span>
<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"l"</span>];
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(v);
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// les String</span>
<span class="hljs-keyword">var</span> str = <span class="hljs-string">"lol"</span>;
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> str) {
    <span class="hljs-built_in">console</span>.log(v);
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// les Map et Set (mais PAS WeakMap et WeakSet)</span>
<span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'l'</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">'o'</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
    <span class="hljs-built_in">console</span>.log(v);
    <span class="hljs-comment">// ["l", 1]</span>
    <span class="hljs-comment">// ["o", 2]</span>
}
<span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>().add(<span class="hljs-string">'l'</span>).add(<span class="hljs-string">'o'</span>);
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
    <span class="hljs-built_in">console</span>.log(v);
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
}

<span class="hljs-comment">// Les TypedArray que vous utilisez tous les jours</span>
<span class="hljs-keyword">var</span> int16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">2</span>);
int16[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> int16) {
    <span class="hljs-built_in">console</span>.log(v);
    <span class="hljs-comment">// 42</span>
    <span class="hljs-comment">// 0</span>
}

<span class="hljs-comment">// Même l'objet spécial arguments (que vous</span>
<span class="hljs-comment">// ne devriez plus utiliser avec l'ES6) est un Iterable</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
        <span class="hljs-built_in">console</span>.log(v);
        <span class="hljs-comment">// 'l'</span>
        <span class="hljs-comment">// 'o'</span>
        <span class="hljs-comment">// 'l'</span>
    }
}
test(<span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'l'</span>);

<span class="hljs-comment">// Les NodeList retournés par l'API DOM également !</span>
<span class="hljs-keyword">var</span> matches = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>);
<span class="hljs-keyword">for</span> (m <span class="hljs-keyword">of</span> matches) {
    <span class="hljs-built_in">console</span>.log(m);
    <span class="hljs-comment">// &lt;div id="topSection"&gt;</span>
    <span class="hljs-comment">// &lt;div id="brandLogo"&gt;</span>
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Autre point : Array, TypedArray, Map, Set sont des Iterable mais définissent
aussi des méthodes qui retournent également des Iterable (ça va, vous suivez
toujours ?) :</p>
<ul>
<li>entries() retourne un ensemble des clés/valeurs</li>
<li>keys() retourne les clés</li>
<li>values() retourne les valeurs</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (cleVals <span class="hljs-keyword">of</span> arr.entries()) {
    <span class="hljs-built_in">console</span>.log(cleVals);
    <span class="hljs-comment">// [0, "l"]</span>
    <span class="hljs-comment">// [1, "o"]</span>
    <span class="hljs-comment">// [2, "l"]</span>
}</code></pre>
<p>Détail important, Object n’est pas Iterable mais il n’est pas impossible de
voir apparaitre dans l’ES7 les méthodes entries(), keys() et values() sur
Object. (cf : <a href="https://github.com/tc39/proposal-object-values-entries">Proposition spec</a>)</p>
<h1 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h1>
<p>J’espère que cet article a bien illustré l’importance de ce protocole dans le
langage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent
déjà avantage de ce protocole mais il est au moins aussi important de noter que
cela permet d’établir une convention sur laquelle des librairies externes peuvent
s’appuyer.</p>
<p>Elles peuvent le faire de 2 manières :</p>
<ul>
<li>en proposant des sources de données qui implémentent le protocole (ex:
liste chaînée)</li>
<li>en tant que consommateur du protocole (ex: un algorithme de tri)</li>
</ul>
<h1 id="un-dernier-verre-pour-la-route"><a class="markdownIt-Anchor" href="#un-dernier-verre-pour-la-route">#</a> Un dernier verre pour la route</h1>
<p>Les articles suivants vous permettront d’aller encore plus loin dans le sujet. Vous y
apprendrez notamment qu’un iterator peut retourner en option 2 autres méthodes,
qu’un générateur est à la fois un Iterable et un Iterator, qu’un Iterable peut
être infini ou encore des exemples d’implémentations divers et variés :</p>
<ul>
<li><a href="http://www.2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 in depth : iterators and the for of loop</a></li>
<li><a href="https://ponyfoo.com/articles/es6-iterators-in-depth">ES6 iterators in depth</a></li>
</ul>
<p>La pratique restant le meilleur moyen de se former, le site
<a href="http://es6katas.org/">ES6 Katas</a> est très bien fait pour s’exercer.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/iterators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/iterators/</guid><pubDate>Wed, 09 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Les object literals]]></title><description><![CDATA[<p>Là encore, cette évolution du langage amène un sucre syntaxique bien pratique
lors de l’initialisation d’objets.</p>
<h2 id="nom-des-propri-t-s-raccourcies"><a class="markdownIt-Anchor" href="#nom-des-propri-t-s-raccourcies">#</a> Nom des propriétés raccourcies</h2>
<p>Lorsqu’on crée un objet, il arrive fréquemment que lorsqu’on définisse une
propriété depuis une variable, la clé porte le même nom que la variable.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">var</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname: firstname,
  lastname: lastname,
}</code></pre>
<p>Avec ES2015, on va pouvoir l’écrire comme ça :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">const</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname,
  lastname,
}
<span class="hljs-comment">// { firstname: "Robert", lastname: "Laiponje" }</span></code></pre>
<p>De la même manière, on pourra déclarer des méthodes en se passant du mot clé
<code>function</code>. Idem pour les <em>getter</em> / <em>setter</em>.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {
  get email() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.email()
  },
  set email(email) {
    <span class="hljs-keyword">this</span>.email = email
  },
  validateEmail(email) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  },
}</code></pre>
<h2 id="nom-de-propri-t-s-calcul-es"><a class="markdownIt-Anchor" href="#nom-de-propri-t-s-calcul-es">#</a> Nom de propriétés calculées</h2>
<p>La dernière nouveauté concernant les <em>literal objects</em> va nous permettre
de créer des noms de propriétés depuis une expression, directement à la
création de l’objet. Auparavant, il fallait procéder en 2 temps, création
puis affectation.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">var</span> payload = {}
  payload[type] = data
  <span class="hljs-keyword">return</span> payload
}</code></pre>
<p>En ES2015, cela donnerait :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">return</span> {
    [type]: data
  }
}</code></pre>
<p><strong>À noter</strong> qu’avec l’introduction des propriétés calculées, on va pouvoir
aussi déclarer plusieurs fois une même propriété, la dernière déclaration
écrasant les précédentes (et plus de <code>syntaxError</code>).</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/object-literals/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/object-literals/</guid><pubDate>Tue, 08 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Object literals]]></title><description><![CDATA[<p>Again, ES6 brings us more syntax sugar, that you might appreciate when
creating new object.</p>
<h2 id="shorter-property-name"><a class="markdownIt-Anchor" href="#shorter-property-name">#</a> Shorter property name</h2>
<p>When you create an object, you might create a variable and then reuse it to
define a property of an object that have the same name.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">var</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname: firstname,
  lastname: lastname,
}</code></pre>
<p>Thanks to ES6, you can directly write:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">const</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname,
  lastname,
}
<span class="hljs-comment">// { firstname: "Robert", lastname: "Laiponje" }</span></code></pre>
<p>In the same spirit, you will be able to declare methods without the <code>function</code>
keyword (this also apply for <em>getter</em> and <em>setter</em>).</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {
  get email() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.email()
  },
  set email(email) {
    <span class="hljs-keyword">this</span>.email = email
  },
  validateEmail(email) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  },
}</code></pre>
<h2 id="dynamic-property-name"><a class="markdownIt-Anchor" href="#dynamic-property-name">#</a> Dynamic property name</h2>
<p>One last thing for <em>objects literal</em> will allow you to create dynamic property
name using an expression, directly when you create an object.
With ES5 you have to do that in two steps:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">var</span> payload = {}
  payload[type] = data
  <span class="hljs-keyword">return</span> payload
}</code></pre>
<p>Now with ES6, you can do:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">return</span> {
    [type]: data
  }
}</code></pre>
<p><strong>Note:</strong> with dynamic properties, declaring multiples properties with the same
name is accepted and do not throw an error. Keep in mind that only the last
value will be kept.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/object-literals/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/object-literals/</guid><pubDate>Tue, 08 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les template strings]]></title><description><![CDATA[<p>ES2015 ajoute le support des <em>template strings</em> qui va permettre enfin de se
simplifier la vie lorsqu’on doit manipuler des chaînes de caractères.</p>
<h2 id="le-principe"><a class="markdownIt-Anchor" href="#le-principe">#</a> Le principe</h2>
<p>Pour définir une chaîne en JavaScript, il faut utiliser soit des single quotes,
soit des double quotes. Malheureusement ces délimiteurs posent quelques
problèmes lorsque justement la chaîne contient un single quote ou une
double quote.</p>
<p>Ainsi, les <em>template strings</em> utilisent le caractère <em>back-tick</em> (accent grave
simple) pour délimiter les chaînes de caractères.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'Je suis une "chaîne de caractères"'</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> myNewString = <span class="hljs-string">`Je suis une "template string"`</span></code></pre>
<p>Jusque là, rien de bien novateur mais voyons un exemple que l’on rencontre
tout le temps : l’interpolation d’expression dans les chaînes de texte.</p>
<h2 id="interpolation-d-expression"><a class="markdownIt-Anchor" href="#interpolation-d-expression">#</a> Interpolation d’expression</h2>
<p>On peut maintenant directement utiliser les variables dans une <em>template string</em>
si on les insère dans un placeholder qui s’écrit <code>${variable}</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">var</span> myStrin = <span class="hljs-string">"Hello "</span> + name; <span class="hljs-comment">// =&gt; Hello world</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> newName = <span class="hljs-string">`developer`</span>;
<span class="hljs-keyword">const</span> myStrin = <span class="hljs-string">`Hello <span class="hljs-subst">${ newName }</span>`</span>; <span class="hljs-comment">// =&gt; Hello developer</span></code></pre>
<p>Il est également possible de faire des traitements dans un placeholder et
d’appeler des fonctions.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${ x }</span> + <span class="hljs-subst">${ y }</span> = <span class="hljs-subst">${ x + y }</span>`</span> <span class="hljs-comment">// =&gt; 1 + 2 = 3</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">return</span> num * num;
}
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${square(5)}</span>`</span> <span class="hljs-comment">// =&gt; 25</span></code></pre>
<p>Ce qui rend l’utilisation des <em>template strings</em> extrêmement intéressante.</p>
<h2 id="les-template-strings-multi-lignes"><a class="markdownIt-Anchor" href="#les-template-strings-multi-lignes">#</a> Les <em>template strings</em> multi-lignes</h2>
<p>Une autre avancée des <em>template strings</em> est le support multi-ligne, en effet en
ES5 il n’existe aucune solution esthétique (et pratique) pour générer des
chaînes multi-lignes.
Ce problème disparait avec les <em>template strings</em>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> multiline = <span class="hljs-string">"foo \
                 bar \
                 baz"</span>;

<span class="hljs-keyword">var</span> multiline2 = <span class="hljs-string">"foo"</span>;
multiline2 += <span class="hljs-string">"bar"</span>;
multiline2 += <span class="hljs-string">"baz"</span>;

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`foo
                   bar
                   baz`</span>;</code></pre>
<p><em>Attention</em> cependant, les espaces sont conservés avec les <em>template strings</em>,
ce qui peut surprendre si vous devez tester des strings multi-lignes.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">`foo
bar`</span>;

<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`foo
             bar`</span>;

str1 === str2 <span class="hljs-comment">// =&gt; false</span></code></pre>
<h2 id="les-template-strings-taggu-s"><a class="markdownIt-Anchor" href="#les-template-strings-taggu-s">#</a> Les <em>template strings</em> taggués</h2>
<p>On entre dans les fonctions moins connues et peu utilisées des <em>template strings</em>.
Les tags sont des fonctions que l’on place juste avant une <em>template string</em> et
qui permettent de modifier le contenu de la dite chaîne de caractères.</p>
<p>Ce tag aura pour paramètres un tableau de “literals” (les chaînes de caractères),
et ensuite tous les paramètres correspondant aux valeurs interpolées qui auront
déjà été évaluées, mais que l’on pourra quand même modifier.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalizeVowels</span>(<span class="hljs-params">strings, ...values</span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceVowels</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> string.replace(<span class="hljs-regexp">/[aeiou]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> c.toUpperCase();
    });
  }

  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; ++i) {
    <span class="hljs-keyword">const</span> nextValue = values[i] || <span class="hljs-string">""</span>;
    result += replaceVowels(strings[i]);
    <span class="hljs-keyword">if</span>(! <span class="hljs-built_in">parseInt</span>(nextValue)) {
      result += replaceVowels(nextValue)
    } <span class="hljs-keyword">else</span> {
      result += nextValue;
    }
  }
  <span class="hljs-keyword">return</span> result;
}


capitalizeVowels<span class="hljs-string">`foo bar ?`</span> <span class="hljs-comment">// =&gt; fOO bAr ?</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-number">42</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-string">"f"</span>
<span class="hljs-keyword">const</span> v = <span class="hljs-string">"o"</span>
capitalizeVowels<span class="hljs-string">`foo <span class="hljs-subst">${ n }</span> bar <span class="hljs-subst">${ c }</span><span class="hljs-subst">${ v }</span><span class="hljs-subst">${ v }</span> ?`</span> <span class="hljs-comment">// =&gt; fOO 42 bAr fOO ?</span></code></pre>
<p>Voici un exemple intéressant d’utilisation des <em>template strings</em> taggués qui
présente un système <a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">de localisation de chaînes de caractères</a>.</p>
<h2 id="string-raw"><a class="markdownIt-Anchor" href="#string-raw">#</a> String.raw</h2>
<p>Et pour finir, une nouvelle fonction a été ajoutée au prototype de <code>String</code> qui
permet d’afficher le contenu d’un <em>template string</em> brut. C’est à dire que la
fonction permettra de voir les caractères d’échappement qui sont
automatiquement gérés avec une <em>template string</em>.</p>
<pre><code class="language-js"><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`FOO\nbar`</span> <span class="hljs-comment">// =&gt; FOO\\nbar</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Les <em>template strings</em> sont bien utiles au quotidien, l’ajout de l’interpolation
simplifie grandement la vie et permet d’oublier les erreurs d’échappement.</p>
<p>Aujourd’hui, <a href="https://kangax.github.io/compat-table/es6/#test-template_strings">la grande majorité des navigateurs les supportent</a>
ainsi que babel et traceur, donc usez et abusez des <em>template strings</em>…</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/template-strings/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/template-strings/</guid><pubDate>Mon, 07 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Template strings]]></title><description><![CDATA[<p>ES2015 add a new way to write better strings that will simplify our code:
the <em>template strings</em>.</p>
<h2 id="principle"><a class="markdownIt-Anchor" href="#principle">#</a> Principle</h2>
<p>To define a string in JavaScript, we have single quotes or double quotes.
No one is really better than the other since you need to escape the quotes you
are using in the string itself.</p>
<p><em>Template strings</em> use <em>back-tick</em> (grave accent) to delimitate strings.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'I\'m a "string"'</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> myNewString = <span class="hljs-string">`I'm a "template string"`</span></code></pre>
<p>Nothing really awesome. So let’s see the interesting new feature: interpolation.</p>
<h2 id="interpolation"><a class="markdownIt-Anchor" href="#interpolation">#</a> Interpolation</h2>
<p>Now you can directly use expression in a <em>template string</em> if you use the new
place holder syntax.: <code>${ expression }</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">var</span> myStrin = <span class="hljs-string">"Hello "</span> + name; <span class="hljs-comment">// =&gt; Hello world</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> newName = <span class="hljs-string">`developer`</span>;
<span class="hljs-keyword">const</span> myStrin = <span class="hljs-string">`Hello <span class="hljs-subst">${ newName }</span>`</span>; <span class="hljs-comment">// =&gt; Hello developer</span></code></pre>
<p>Here we are just using a variable, but we can use any expression:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${ x }</span> + <span class="hljs-subst">${ y }</span> = <span class="hljs-subst">${ x + y }</span>`</span> <span class="hljs-comment">// =&gt; 1 + 2 = 3</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">return</span> num * num;
}
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${square(5)}</span>`</span> <span class="hljs-comment">// =&gt; 25</span></code></pre>
<p>This is what make <em>template strings</em> awesome.</p>
<h2 id="template-strings-are-multi-lines-capable"><a class="markdownIt-Anchor" href="#template-strings-are-multi-lines-capable">#</a> <em>template strings</em> are multi-lines capable</h2>
<p>Another cool thing is that <em>template strings</em> handle multi-lines.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> multiline = <span class="hljs-string">"foo \
                 bar \
                 baz"</span>;

<span class="hljs-keyword">var</span> multiline2 = <span class="hljs-string">"foo"</span>;
multiline2 += <span class="hljs-string">"bar"</span>;
multiline2 += <span class="hljs-string">"baz"</span>;

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`foo
                   bar
                   baz`</span>;</code></pre>
<p><em>Note</em> keep in mind that spaces are as you write them, which can surprise you.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">`foo
bar`</span>;

<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`foo
             bar`</span>;

str1 === str2 <span class="hljs-comment">// =&gt; false</span></code></pre>
<h2 id="tagged-template-strings"><a class="markdownIt-Anchor" href="#tagged-template-strings">#</a> Tagged <em>template strings</em></h2>
<p>Let’s dive into another interesting feature of <em>template strings</em>.
Tags are functions that will use just before the <em>template string</em> and they
allow us to enhance the string result.</p>
<p>A tag take an array of “literals” (strings), and then all interpolated
(evaluated) expressions that we can still modify.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalizeVowels</span>(<span class="hljs-params">strings, ...values</span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceVowels</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> string.replace(<span class="hljs-regexp">/[aeiou]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> c.toUpperCase();
    });
  }

  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; ++i) {
    <span class="hljs-keyword">const</span> nextValue = values[i] || <span class="hljs-string">""</span>;
    result += replaceVowels(strings[i]);
    <span class="hljs-keyword">if</span>(! <span class="hljs-built_in">parseInt</span>(nextValue)) {
      result += replaceVowels(nextValue)
    } <span class="hljs-keyword">else</span> {
      result += nextValue;
    }
  }
  <span class="hljs-keyword">return</span> result;
}


capitalizeVowels<span class="hljs-string">`foo bar ?`</span> <span class="hljs-comment">// =&gt; fOO bAr ?</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-number">42</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-string">"f"</span>
<span class="hljs-keyword">const</span> v = <span class="hljs-string">"o"</span>
capitalizeVowels<span class="hljs-string">`foo <span class="hljs-subst">${ n }</span> bar <span class="hljs-subst">${ c }</span><span class="hljs-subst">${ v }</span><span class="hljs-subst">${ v }</span> ?`</span> <span class="hljs-comment">// =&gt; fOO 42 bAr fOO ?</span></code></pre>
<p>Here is an interesting example of tagged <em>template strings</em> to handle
<a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">i18n for strings</a>.</p>
<h2 id="string-raw"><a class="markdownIt-Anchor" href="#string-raw">#</a> String.raw</h2>
<p>A new function has been added to <code>String</code> prototype that allows us display raw
content so you can see unescaped characters:</p>
<pre><code class="language-js"><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`FOO\nbar`</span> <span class="hljs-comment">// =&gt; FOO\\nbar</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>When you will start to use <em>template strings</em>, you are likely going to like
them. They are clearly really useful in a daily basis.</p>
<p>Almost all
<a href="https://kangax.github.io/compat-table/es6/#test-template_strings">modern browser handle template strings</a>
today, as well as <a href="http://babeljs.io/">Babel</a> and Traceur, so you do not
hesitate to use <em>template strings</em>.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/template-strings/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/template-strings/</guid><pubDate>Mon, 07 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les promesses]]></title><description><![CDATA[<p>ES2015 apporte une fonctionnalité simplifiant grandement l’asynchrone en
JavaScript, les promesses ! Visible depuis longtemps dans l’écosystème
JavaScript grâce a diverses librairies, on peut maintenant utiliser directement
la spécification officielle.</p>
<h2 id="c-est-quoi-une-promesse"><a class="markdownIt-Anchor" href="#c-est-quoi-une-promesse">#</a> C’est quoi une promesse ?</h2>
<p>Et bien comme son nom l’indique vous pouvez voir ça comme la promesse que vous
allez recevoir une valeur. Comme toute promesse, elle peut être tenue,
la valeur est arrivée et on peut s’en servir, ou ne pas l’être, dans ce cas
une erreur arrive et on peut réagir en conséquence.</p>
<p>Ce mécanisme permet de remplacer les callbacks d’une manière plus élégante. Au
revoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez
pas ? Voici un exemple pour vous le prouver :</p>
<pre><code class="language-js"><span class="hljs-comment">// En utilisant les callbacks</span>
<span class="hljs-comment">// Imaginez que chacune de ces fonctions effectue des tâches asynchrones</span>
<span class="hljs-comment">// plus ou moins complexes (requête HTTP, appel à une base de données</span>
<span class="hljs-comment">// ou encore lecture de fichier)</span>
<span class="hljs-keyword">const</span> functionWithCallback1 = (callback) =&gt; callback(<span class="hljs-string">'test'</span>, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback2 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback3 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback4 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback5 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback6 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)

functionWithCallback1((result1, err) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">throw</span> err
  }
  functionWithCallback2(result1, (result2, err) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">throw</span> err
    }
    functionWithCallback3(result2, (result3, err) =&gt; {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">throw</span> err
      }
      functionWithCallback4(result3, (result4, err) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">throw</span> err
        }
        functionWithCallback5(result4, (result5, err) =&gt; {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">throw</span> err
          }
          functionWithCallback6(result5, (result6, err) =&gt; {
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">throw</span> err
            }
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Exemple avec les callback : <span class="hljs-subst">${result6}</span>`</span>)
          })
        })
      })
    })
  })
})

<span class="hljs-comment">// Et maintenant, en utilisant les promesses</span>
<span class="hljs-keyword">const</span> functionWithPromise1 = () =&gt; <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>)
<span class="hljs-keyword">const</span> functionWithPromise2 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise3 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise4 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise5 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise6 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)

functionWithPromise1()
  .then(functionWithPromise2)
  .then(functionWithPromise3)
  .then(functionWithPromise4)
  .then(functionWithPromise5)
  .then(functionWithPromise6)
  .then(result =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Exemple avec les promesses : <span class="hljs-subst">${result}</span>`</span>))
  .catch(err =&gt; {
    <span class="hljs-keyword">throw</span> err
  })</code></pre>
<p>Comme vous pouvez le voir, l’exemple avec les promesses est tout de même plus
lisible !</p>
<h2 id="trop-bien-comment-je-les-utilise"><a class="markdownIt-Anchor" href="#trop-bien-comment-je-les-utilise">#</a> Trop bien ! Comment je les utilise ?</h2>
<p>Une promesse peut avoir plusieurs états au cours de son existence :</p>
<ul>
<li>en cours : la valeur qu’elle contient n’est pas encore arrivée</li>
<li>résolue : la valeur est arrivée, on peut l’utiliser</li>
<li>rejetée : une erreur est survenue, on peut y réagir</li>
</ul>
<p>Une promesse possède 2 fonctions : <code>then</code> et <code>catch</code>, vous pouvez utiliser
<code>then</code> pour récupérer le resultat ou l’erreur d’une promesse et <code>catch</code> pour
récupérer l’erreur d’une ou plusieurs promesses.</p>
<p>Voyons comment utiliser les promesses à l’aide de la future implémentation de
<a href="https://fetch.spec.whatwg.org"><code>fetch</code></a>.</p>
<pre><code class="language-js"><span class="hljs-comment">// À ce moment, la promesse est en attente</span>
<span class="hljs-keyword">const</span> fetchPromise = fetch(<span class="hljs-string">'http://putaindecode.io'</span>)

<span class="hljs-comment">// Quand la requête est terminée la promesse est résolue avec le résultat de</span>
<span class="hljs-comment">// la requête</span>
<span class="hljs-keyword">const</span> parsePromise = fetchPromise.then(fetchResult =&gt; {
  <span class="hljs-comment">// Je peux retourner une nouvelle promesse à partir d'un then, ici</span>
  <span class="hljs-comment">// j'appelle .text() qui parse le contenu de la requête et retourne</span>
  <span class="hljs-comment">// une promesse</span>
  <span class="hljs-keyword">return</span> fetchResult.text()
})

<span class="hljs-comment">// Quand le parsing est terminé, je peux recuperer son contenu</span>
parsePromise.then(textResult =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
})

<span class="hljs-comment">// Si la requête a un problème, la promesse est rejetée avec une erreur</span>
fetchPromise.catch(fetchError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête"</span>, fetchError)
})

<span class="hljs-comment">// S'il y a une erreur pendant le parsing, je peux la récupérer</span>
parsePromise.catch(parseError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant le parsing"</span>, parseError)
})

<span class="hljs-comment">// Cela peut aussi être écrit</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(fetchResult =&gt; fetchResult.text())
  .then(textResult =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
  })
  .catch(error =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête ou le parsing"</span>, fetchError)
  })

<span class="hljs-comment">// Ou encore</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(
    fetchResult =&gt; {
      <span class="hljs-keyword">return</span> fetchResult.text()
    },
    fetchError =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête"</span>, fetchError)
    }
  )
  .then(
    textResult =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
    },
    parseError =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant le parsing"</span>, parseError)
    }
  )</code></pre>
<h2 id="mais-comment-je-cr-e-mes-propres-promesses"><a class="markdownIt-Anchor" href="#mais-comment-je-cr-e-mes-propres-promesses">#</a> Mais comment je crée mes propres promesses ?</h2>
<p>C’est bien beau d’utiliser les promesses, mais c’est encore mieux de savoir
créer les vôtres ! Je vous rassure, c’est très simple.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> functionThatReturnAPromise = (success) =&gt; {
  <span class="hljs-comment">// On utilise la classe Promise pour en créer une, le constructeur prend 2</span>
  <span class="hljs-comment">// fonctions en paramètre :</span>
  <span class="hljs-comment">// - resolve que l'on pourra appeler avec le résultat de notre fonction</span>
  <span class="hljs-comment">// - reject que l'on pourra appeler avec une erreur s'il y a une erreur</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    <span class="hljs-keyword">if</span> (success) {
      resolve(<span class="hljs-string">'success'</span>)
    }
    <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">'failed'</span>)
    }
  })
}

<span class="hljs-comment">// Vous pouvez maintenant utiliser votre fonction comme vu précédemment</span>
functionThatReturnAPromise(success)
  .then(res =&gt; <span class="hljs-built_in">console</span>.log(res))
  .catch(error =&gt; <span class="hljs-built_in">console</span>.log(error))

<span class="hljs-comment">// équivalent dans notre cas à</span>
functionThatReturnAPromise(success)
  .then(
    (res) =&gt; <span class="hljs-built_in">console</span>.log(res),
    (error) =&gt; <span class="hljs-built_in">console</span>.log(error)
  )</code></pre>
<h2 id="et-demain"><a class="markdownIt-Anchor" href="#et-demain">#</a> Et demain ?</h2>
<p>Une fonctionnalité encore plus pratique que les promesses arrive en JavaScript,
les mots-clés <code>async</code> et <code>await</code> ! Ces mots-clés vous permettront d’avoir un
code encore plus lisible quand vous ferez de l’asynchrone, mais ça ne concerne
pas ES2015 :)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/promises/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/promises/</guid><pubDate>Sun, 06 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Promises]]></title><description><![CDATA[<p>With ES2015, you can now very easily write asynchronous code thanks to the
promises.
The concept of promises exists is not new in the JavaScript world, but now
we got an official feature!</p>
<h2 id="what-s-a-promise"><a class="markdownIt-Anchor" href="#what-s-a-promise">#</a> What’s a promise?</h2>
<p>It’s a promise of an incoming value, not available yet. It’s a promise so it can
be fulfilled or not (rejected). If fulfilled, it will give us the the value we
were waiting for. If rejected, we will get the error so we can handle it.</p>
<p>This mechanism allows to avoid the callback hell :</p>
<pre><code class="language-js"><span class="hljs-comment">// With callbacks.</span>
<span class="hljs-comment">// Let's say that all those function are doing async tasks (like http or</span>
<span class="hljs-comment">// database request, fs read...)</span>
<span class="hljs-keyword">const</span> functionWithCallback1 = (callback) =&gt; callback(<span class="hljs-string">'test'</span>, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback2 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback3 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback4 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback5 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback6 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)

functionWithCallback1((result1, err) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">throw</span> err
  }
  functionWithCallback2(result1, (result2, err) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">throw</span> err
    }
    functionWithCallback3(result2, (result3, err) =&gt; {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">throw</span> err
      }
      functionWithCallback4(result3, (result4, err) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">throw</span> err
        }
        functionWithCallback5(result4, (result5, err) =&gt; {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">throw</span> err
          }
          functionWithCallback6(result5, (result6, err) =&gt; {
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">throw</span> err
            }
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example with callbacks: <span class="hljs-subst">${result6}</span>`</span>)
          })
        })
      })
    })
  })
})

<span class="hljs-comment">// Now the same thing with promises</span>
<span class="hljs-keyword">const</span> functionWithPromise1 = () =&gt; <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>)
<span class="hljs-keyword">const</span> functionWithPromise2 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise3 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise4 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise5 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise6 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)

functionWithPromise1()
  .then(functionWithPromise2)
  .then(functionWithPromise3)
  .then(functionWithPromise4)
  .then(functionWithPromise5)
  .then(functionWithPromise6)
  .then(result =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example with promises: <span class="hljs-subst">${result}</span>`</span>))
  .catch(err =&gt; {
    <span class="hljs-keyword">throw</span> err
  })</code></pre>
<p>As you can see, example with promises is clear and more concise.</p>
<h2 id="that-s-cool-how-can-i-use-promises"><a class="markdownIt-Anchor" href="#that-s-cool-how-can-i-use-promises">#</a> That’s cool. How can I use promises?</h2>
<p>A promise can have different status:</p>
<ul>
<li>in progress: value is not ready yet</li>
<li>resolved: value is here, we can use it</li>
<li>rejected: an error has been thrown, we should handle it.</li>
</ul>
<p>A promise have 2 functions: <code>then</code> and <code>catch</code>.
You can use <code>then</code> to wait for the result (or handle an error), and <code>catch</code> to
catch all possibles errors of one promise or more.</p>
<p>Let’s see how to use promises with an example of the incoming standardized
<a href="https://fetch.spec.whatwg.org"><code>fetch</code></a> method.</p>
<pre><code class="language-js"><span class="hljs-comment">// At this moment, promise is in progress</span>
<span class="hljs-keyword">const</span> fetchPromise = fetch(<span class="hljs-string">'http://putaindecode.io'</span>)

<span class="hljs-comment">// When promise is resolved, you go a value you can work with</span>
<span class="hljs-keyword">const</span> parsePromise = fetchPromise.then(fetchResult =&gt; {
  <span class="hljs-comment">// I can return a new result that can be used as a new promise</span>
  <span class="hljs-comment">// Here we call .text() which parse the content of the request and return</span>
  <span class="hljs-comment">// promise</span>
  <span class="hljs-keyword">return</span> fetchResult.text()
})

<span class="hljs-comment">// When parsing is done, we can work with the content</span>
parsePromise.then(textResult =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
})

<span class="hljs-comment">// If the request encounter an issue, promise might be rejected with an error</span>
fetchPromise.catch(fetchError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request`</span>, fetchError)
})

<span class="hljs-comment">// If there is an issue during the parsing, we can handle it too</span>
parsePromise.catch(parseError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"We got an issue during the parsing"</span>, parseError)
})

<span class="hljs-comment">// The same can be written like this</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then((fetchResult) =&gt; fetchResult.text())
  .then((textResult) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
  })
  .catch((error) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request or the parsing`</span>, fetchError)
  })

<span class="hljs-comment">// Or like this</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(
    (fetchResult) =&gt; {
      <span class="hljs-keyword">return</span> fetchResult.text()
    },
    (fetchError) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request`</span>, fetchError)
    })
  .then(
    (textResult) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
    },
    (parseError) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"We got an issue during the parsing"</span>, parseError)
    }
  )</code></pre>
<h2 id="how-do-i-create-my-own-promises"><a class="markdownIt-Anchor" href="#how-do-i-create-my-own-promises">#</a> How do I create my own promises?</h2>
<p>Using a promise is nice, but creating yours is even better. Let’s be clear: it’s
easy.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> functionThatReturnAPromise = (success) =&gt; {
  <span class="hljs-comment">// We will need to use Promise class to use one.</span>
  <span class="hljs-comment">// constructor takes 2 arguments:</span>
  <span class="hljs-comment">// - resolve, a callback to pass the value you want to send</span>
  <span class="hljs-comment">// - reject, a callback to throw an error</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    <span class="hljs-keyword">if</span> (success) {
      resolve(<span class="hljs-string">'success'</span>)
    }
    <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">'failed'</span>)
    }
  })
}

<span class="hljs-comment">// You can use this promise like this</span>
functionThatReturnAPromise(success)
  .then(res =&gt; <span class="hljs-built_in">console</span>.log(res))
  .catch(error =&gt; <span class="hljs-built_in">console</span>.log(error))

<span class="hljs-comment">// In our case, the previous example can be also written</span>
functionThatReturnAPromise(success)
  .then(
    (res) =&gt; <span class="hljs-built_in">console</span>.log(res),
    (error) =&gt; <span class="hljs-built_in">console</span>.log(error)
  )</code></pre>
<h2 id="what-s-next"><a class="markdownIt-Anchor" href="#what-s-next">#</a> What’s next?</h2>
<p>A new way to write asynchronous will land in JavaScript with <code>async</code> and <code>await</code>
keywords, but we will need to way another ES year (or two) for it !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/promises/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/promises/</guid><pubDate>Sun, 06 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les classes]]></title><description><![CDATA[<p>Les classes introduites par <code>ES2015</code> ne sont clairement que du sucre syntaxique.
Elles n’apportent rien de plus en terme de fonctionnalité. Toutefois, l’objectif
de cette évolution est de rendre le code plus lisible et plus facilement
accessible.</p>
<h2 id="d-claration-de-classes"><a class="markdownIt-Anchor" href="#d-claration-de-classes">#</a> Déclaration de classes</h2>
<p>Oubliez les fonctions anonymes et les prototypes, la sémantique a pris le
relais, comme vous pouvez le constater dans l’exemple de déclaration de la
classe <code>User</code> :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-comment">// méthode constructor</span>
  constructor(firstname, lastname) {
    <span class="hljs-keyword">this</span>.firstname = firstname;
    <span class="hljs-keyword">this</span>.lastname = lastname;
  }

  sayName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span> <span class="hljs-subst">${this.lastname}</span>`</span>
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<p>Pour rappel, voici une <a href="https://gist.github.com/magsout/a876b2fa8240a987e523">façon possible
d’écrire</a> cette classe en
<code>es5</code> :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">firstname, lastname</span>) </span>{
  <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> User)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Class constructors cannot be invoked without 'new'"</span>)
  }
  <span class="hljs-keyword">this</span>.firstname = firstname
  <span class="hljs-keyword">this</span>.lastname = lastname
}

User.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastname
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<h2 id="expressions-de-classes"><a class="markdownIt-Anchor" href="#expressions-de-classes">#</a> Expressions de classes</h2>
<p>Toutes les méthodes s’écrivent comme de simples fonctions à l’intérieur de la
classe. Bien entendu, les getter/setter sont toujours de la partie mais bien
plus simples à utiliser :</p>
<pre><code class="language-JS"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-comment">// constructor</span>
  constructor(firstname, lastname, type) {
    <span class="hljs-keyword">this</span>.firstname = firstname
    <span class="hljs-keyword">this</span>.lastname = lastname
    <span class="hljs-keyword">this</span>.type = type
  }

  <span class="hljs-comment">// méthode</span>
  sayName() {
   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span>  <span class="hljs-subst">${this.lastname}</span>`</span>
  }

  <span class="hljs-comment">// getter</span>
  get role() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type
  }

  <span class="hljs-comment">// setter</span>
  set role(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type = value
  }
}

<span class="hljs-comment">// le `new` est obligatoire pour appeler une classe</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-string">"Contributor"</span>)

<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Contributor</span>
user.role = <span class="hljs-string">"owner"</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Owner</span></code></pre>
<h2 id="l-h-ritage"><a class="markdownIt-Anchor" href="#l-h-ritage">#</a> L’héritage</h2>
<p>Pour qu’une sous-classe hérite d’une autre classe on utilisera le mot
clé <code>extends</code>.</p>
<p>En utilisant notre exemple précédent :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, numberCommit) {

    <span class="hljs-comment">// le mot clé super est utilisé comme super contructeur. Il permet d'appeler</span>
    <span class="hljs-comment">// et d'avoir accès aux méthodes du parent</span>
    <span class="hljs-keyword">super</span>(firstname, lastname)
    <span class="hljs-keyword">this</span>.numberCommit = numberCommit
  }

  sayNameWithCommit() {
    <span class="hljs-comment">// on peut appeler une méthode de la classe parente avec `super.method`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.sayName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.sayNumberCommit()
  }

  sayNumberCommit() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numberCommit
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> contributor = <span class="hljs-keyword">new</span> Contributor(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Smith'</span>, <span class="hljs-number">10</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(contributor.sayName())
<span class="hljs-built_in">console</span>.log(contributor.sayNumberCommit())</code></pre>
<p><strong>Rappel : <a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">préférez la composition à l’héritage</a>.</strong></p>
<h2 id="that-s-it"><a class="markdownIt-Anchor" href="#that-s-it">#</a> That’s it</h2>
<p>Concrètement, tout ce qui est possible de faire avec cette nouvelle notation
l’était bien entendu
<a href="https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1">avant</a>.</p>
<p>Au final, on gagne en clarté, en lisibilité et donc en maintenabilité.</p>
<p>À l’heure actuelle, il est nécessaire de passer par un transpileur comme
<a href="https://babeljs.io/">babel</a> pour utiliser les classes.</p>
<p>Une dernière petite chose, en utilisant les classes on active automatiquement le
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode">mode strict</a>,
il n’est donc pas nécessaire de le rajouter manuellement.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/classes/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/classes/</guid><pubDate>Sat, 05 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Classes]]></title><description><![CDATA[<p>Classes introduced by ES2015 are just some syntax sugar.
They don’t really bring anything.
That said, this can helps to improve code readability and make the code more
accessible.</p>
<h2 id="class-declaration"><a class="markdownIt-Anchor" href="#class-declaration">#</a> Class declaration</h2>
<p>Forget functions and prototypes, semantic is taking the relay as you will see in
the following example :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname) {
    <span class="hljs-keyword">this</span>.firstname = firstname;
    <span class="hljs-keyword">this</span>.lastname = lastname;
  }

  sayName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span> <span class="hljs-subst">${this.lastname}</span>`</span>
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// call of the method sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<p>As a reminder, here is one
<a href="https://gist.github.com/magsout/a876b2fa8240a987e523">way to code</a>
this class in <code>es5</code> :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">firstname, lastname</span>) </span>{
  <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> User)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Class constructors cannot be invoked without 'new'"</span>)
  }
  <span class="hljs-keyword">this</span>.firstname = firstname
  <span class="hljs-keyword">this</span>.lastname = lastname
}

User.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastname
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// call of the method sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<h2 id="classes-expressions"><a class="markdownIt-Anchor" href="#classes-expressions">#</a> Classes expressions</h2>
<p>All methods should be written as simple function inside the class.
You might denote the nice way to write getter and setter :</p>
<pre><code class="language-JS"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, type) {
    <span class="hljs-keyword">this</span>.firstname = firstname
    <span class="hljs-keyword">this</span>.lastname = lastname
    <span class="hljs-keyword">this</span>.type = type
  }

  <span class="hljs-comment">// method</span>
  sayName() {
   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span>  <span class="hljs-subst">${this.lastname}</span>`</span>
  }

  <span class="hljs-comment">// getter</span>
  get role() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type
  }

  <span class="hljs-comment">// setter</span>
  set role(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type = value
  }
}

<span class="hljs-comment">// the `new` is mandatory to instanciate a class</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-string">"Contributor"</span>)

<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Contributor</span>
user.role = <span class="hljs-string">"owner"</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Owner</span></code></pre>
<h2 id="inheritance"><a class="markdownIt-Anchor" href="#inheritance">#</a> Inheritance</h2>
<p>In order to have a class that inherite from another, we have the <code>extends</code>
keyword.</p>
<p>Here is the an example :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, numberCommit) {

    <span class="hljs-comment">// keyword `super` is used to call the constructor of the parent class</span>
    <span class="hljs-keyword">super</span>(firstname, lastname)
    <span class="hljs-keyword">this</span>.numberCommit = numberCommit
  }

  sayNameWithCommit() {
    <span class="hljs-comment">// we can can also use `super` to call a method of the parent class</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.sayName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.sayNumberCommit()
  }

  sayNumberCommit() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numberCommit
  }
}

<span class="hljs-keyword">const</span> contributor = <span class="hljs-keyword">new</span> Contributor(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Smith'</span>, <span class="hljs-number">10</span>)

<span class="hljs-built_in">console</span>.log(contributor.sayName())
<span class="hljs-built_in">console</span>.log(contributor.sayNumberCommit())</code></pre>
<p><strong>Reminder: <a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">prefer inheritance to composition</a>.</strong></p>
<h2 id="that-s-it"><a class="markdownIt-Anchor" href="#that-s-it">#</a> That’s it</h2>
<p>As you saw, all what you can do know was already possible
<a href="https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1">before</a>.</p>
<p>We just have a more readable code that should be more easily maintainable.</p>
<p>For now, you will need to use a transpiler like <a href="https://babeljs.io/">babel</a>
to be able to use classes.</p>
<p>One last thing: when you are in a class context,
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a>
is enabled automatically.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/classes/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/classes/</guid><pubDate>Sat, 05 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Object.assign]]></title><description><![CDATA[<p>You probably know underscore or lodash <code>extend</code> method (at leat lodash right)?
Like most of these utilities functions, those are deprecated by an ES6 (ES2015)
feature.</p>
<h1 id="object-assign"><a class="markdownIt-Anchor" href="#object-assign">#</a> Object.assign</h1>
<p>The new static method <code>Object.assign</code> take a bunch of objects as arguments :</p>
<ul>
<li>The first is a target for copies;</li>
<li>Next are sources;</li>
<li>All <em>own properties</em> (enumerable keys and non inherited, even those which are
<code>undefined</code>) will be copied  in the target (so last ones take precedences);</li>
<li><strong>The target object is modified</strong> (it must be mutable);</li>
<li>The modified target object is returned.</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = { y: <span class="hljs-number">0</span> }
<span class="hljs-keyword">const</span> o1 = { x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> }
<span class="hljs-keyword">const</span> o2 = { x: <span class="hljs-literal">undefined</span>, z: <span class="hljs-number">3</span> }
<span class="hljs-built_in">Object</span>.assign(o, o1, o2) <span class="hljs-comment">// { x: undefined, y: 2, z: 3 }</span>
o <span class="hljs-comment">// { x: undefined, y: 2, z: 3 }</span>
o1 <span class="hljs-comment">// unmodified</span>
o2 <span class="hljs-comment">// unmodified</span></code></pre>
<h2 id="becareful-to-mutability"><a class="markdownIt-Anchor" href="#becareful-to-mutability">#</a> Becareful to mutability</h2>
<p>Be warned that the target is always modified.
Since the most frequent use-case is the creation of a new object that will be
generated from others sources, most of the time we will pass an new empty object
as the first parameter.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o1 = { x: <span class="hljs-number">1</span> }
<span class="hljs-keyword">const</span> o2 = { y: <span class="hljs-number">2</span> }
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.assign({}, o1, o2)
o <span class="hljs-comment">// { x: 1, y: 2 }</span>
<span class="hljs-comment">// o1 and o2 are unmodified</span></code></pre>
<h2 id="specific-use-cases"><a class="markdownIt-Anchor" href="#specific-use-cases">#</a> Specific use-cases</h2>
<h3 id="error-during-the-copy"><a class="markdownIt-Anchor" href="#error-during-the-copy">#</a> Error during the copy</h3>
<p>If a property in the target is read-only, <code>Object.assign</code> should behave like
in strict mode (unlike the <em>wtf</em> mode) and throw an error before stoping the
copy.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create({}, {
  val: { value: <span class="hljs-number">42</span>, enumerable: <span class="hljs-literal">true</span>, writable: <span class="hljs-literal">false</span> }
})

<span class="hljs-comment">// "standard" (wtf) mode:</span>
o.val = <span class="hljs-number">0</span> <span class="hljs-comment">// no error</span>
o.val <span class="hljs-comment">// 42 (unmodified value)</span>
<span class="hljs-built_in">Object</span>.assign(o, { x: <span class="hljs-number">1</span>, val: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span> }) <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
o <span class="hljs-comment">// { val: 42, x: 1 }</span>

<span class="hljs-comment">// "strict" mode:</span>
o.val = <span class="hljs-number">0</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
<span class="hljs-built_in">Object</span>.assign(o, { x: <span class="hljs-number">1</span>, val: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span> }) <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
o <span class="hljs-comment">// { val: 42, x: 1 }</span></code></pre>
<p>Keys that have already been copied before the throwing of the exception will
be kept in the target object, that’s why in our example <code>x</code> have been copied
but not <code>y</code>.</p>
<p>Note: this is theory, but practise show us that this behavior is variable,
depending of the platform and the context, the error might not always be thrown.
To get a predictable behavior, you should work in <em>strict</em> mode.</p>
<h3 id="scalar-sources"><a class="markdownIt-Anchor" href="#scalar-sources">#</a> Scalar sources</h3>
<p>When sources are scalar values (number, boolean, etc) <code>Object.keys</code> will not
return any keys and values will be ignored.
<code>null</code> and <code>undefined</code> will also be ignored.</p>
<p>Particular case: strings are treated as array.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">Object</span>.assign(o, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"toto"</span>, [<span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>], <span class="hljs-literal">undefined</span>)
<span class="hljs-comment">// 1, true, null, undefined are ignored</span>
<span class="hljs-comment">// "toto" is converted to {0: "t", 1: "o", 2: "t", 3: "o"}</span>
<span class="hljs-comment">// ["b", "a"] is converted to {0: "b", 1: "a"}</span>
o <span class="hljs-comment">// {0: "b", 1: "a", 2: "t", 3: "o"}</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>We can forget <code>_.clone</code>, <code>_.extend</code> and friends with this method!</p>
<p>About compatiblity, <code>Object.assign</code> is pretty well supported by all modern
browsers (IE is not considered as modern until 12) :</p>
<ul>
<li>Edge (IE ≥ 12) ;</li>
<li>Chrome stable (46) ;</li>
<li>Firefox stable (42) ;</li>
<li>Node ≥ 4 ;</li>
<li>If you need to support old browsers, you will need <a href="http://babeljs.io">Babel</a>
or one of many users implementations.</li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/object-assign/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/object-assign/</guid><pubDate>Fri, 04 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Object.assign]]></title><description><![CDATA[<p>Vous connaissez les méthodes <code>extend</code> d’underscore ou lodash (mais plutôt
lodash quand même) ? Comme la plupart de ces fonctions utilitaires, elles sont
rendues obsolètes par une fonctionnalité d’ES6 (aka ES2015).</p>
<h1 id="object-assign"><a class="markdownIt-Anchor" href="#object-assign">#</a> Object.assign</h1>
<p>La nouvelle méthode statique <code>Object.assign</code> prend en paramètres une série
d’objets :</p>
<ul>
<li>le premier objet est la “cible” des copies ;</li>
<li>les suivants sont les sources ;</li>
<li>toutes les clés propres (<em>own properties</em>, soit les clés énumérables et non
héritées, même celles dont la valeur est <code>undefined</code>) des sources sont
copiées vers la cible (les suivantes écrasant les précédentes) ;</li>
<li><strong>l’objet cible est donc modifié</strong> (il doit être mutable) ;</li>
<li>puis on retourne l’objet cible.</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = { y: <span class="hljs-number">0</span> }
<span class="hljs-keyword">const</span> o1 = { x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> }
<span class="hljs-keyword">const</span> o2 = { x: <span class="hljs-literal">undefined</span>, z: <span class="hljs-number">3</span> }
<span class="hljs-built_in">Object</span>.assign(o, o1, o2) <span class="hljs-comment">// { x: undefined, y: 2, z: 3 }</span>
o <span class="hljs-comment">// { x: undefined, y: 2, z: 3 }</span>
o1 <span class="hljs-comment">// non modifié</span>
o2 <span class="hljs-comment">// non modifié</span></code></pre>
<h2 id="attention-la-mutabilit"><a class="markdownIt-Anchor" href="#attention-la-mutabilit">#</a> Attention à la mutabilité</h2>
<p>Prenez garde au fait que la source est systématiquement modifiée. Le <em>use-case</em>
général étant plutôt la création d’un nouvel objet résultant de la fusion des
sources, on passera habituellement un nouvel objet en premier paramètre.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o1 = { x: <span class="hljs-number">1</span> }
<span class="hljs-keyword">const</span> o2 = { y: <span class="hljs-number">2</span> }
<span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.assign({}, o1, o2)
o <span class="hljs-comment">// { x: 1, y: 2 }</span>
<span class="hljs-comment">// o1 et o2 n'ont pas été modifiés</span></code></pre>
<h2 id="cas-particuliers"><a class="markdownIt-Anchor" href="#cas-particuliers">#</a> Cas particuliers</h2>
<h3 id="erreurs-lors-de-la-copie"><a class="markdownIt-Anchor" href="#erreurs-lors-de-la-copie">#</a> Erreurs lors de la copie</h3>
<p>Si une propriété de la cible est en lecture seule, <code>Object.assign</code> devrait se
comporter comme en mode <em>strict</em> (par opposition au mode <em>WTF</em>), et lever
l’erreur correspondante avant d’interrompre la copie.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create({}, {
  val: { value: <span class="hljs-number">42</span>, enumerable: <span class="hljs-literal">true</span>, writable: <span class="hljs-literal">false</span> }
})

<span class="hljs-comment">// En mode "standard":</span>
o.val = <span class="hljs-number">0</span> <span class="hljs-comment">// pas d'erreur</span>
o.val <span class="hljs-comment">// 42 (valeur non modifiée)</span>
<span class="hljs-built_in">Object</span>.assign(o, { x: <span class="hljs-number">1</span>, val: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span> }) <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
o <span class="hljs-comment">// { val: 42, x: 1 }</span>

<span class="hljs-comment">// En mode "strict":</span>
o.val = <span class="hljs-number">0</span> <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
<span class="hljs-built_in">Object</span>.assign(o, { x: <span class="hljs-number">1</span>, val: <span class="hljs-number">0</span>, y: <span class="hljs-number">2</span> }) <span class="hljs-comment">// Uncaught TypeError: Cannot assign…</span>
o <span class="hljs-comment">// { val: 42, x: 1 }</span></code></pre>
<p>Les clés déjà copiées avant la levée d’erreur sont conservées dans la cible,
ainsi dans notre exemple <code>x</code> a été copiée mais pas <code>y</code>.</p>
<p>Note : ça c’est la théorie, lors de mes tests ce comportement a été le plus
variable, en fonction de la plate-forme et du contexte, l’erreur n’est pas
toujours levée. Le mieux est de travailler en mode <em>strict</em> pour s’assurer d’un
comportement prédictible.</p>
<h3 id="sources-scalaires"><a class="markdownIt-Anchor" href="#sources-scalaires">#</a> Sources scalaires</h3>
<p>Lorsque les sources sont des valeurs scalaires (nombre, booléen, etc.)
<code>Object.keys</code> ne listera généralement aucune clé et ces valeurs seront donc
ignorées. Les valeurs <code>null</code> et <code>undefined</code> également.</p>
<p>Cas particulier : les chaînes de caractères sont traitées comme des tableaux.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {}
<span class="hljs-built_in">Object</span>.assign(o, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"toto"</span>, [<span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>], <span class="hljs-literal">undefined</span>)
<span class="hljs-comment">// 1, true, null, undefined sont ignorées</span>
<span class="hljs-comment">// "toto" est converti en {0: "t", 1: "o", 2: "t", 3: "o"}</span>
<span class="hljs-comment">// ["b", "a"] est converti en {0: "b", 1: "a"}</span>
o <span class="hljs-comment">// {0: "b", 1: "a", 2: "t", 3: "o"}</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Plus besoin de <code>_.clone</code>, <code>_.extend</code>, etc. avec cette méthode :)</p>
<p>Pour finir, le topo compatibilité : <code>Object.assign</code> est plutôt bien supportée
par les navigateurs modernes (donc pas IE) :</p>
<ul>
<li>Edge (IE ≥ 12) ;</li>
<li>Chrome stable (46) ;</li>
<li>Firefox stable (42) ;</li>
<li>Node ≥ 4 ;</li>
<li>et si vous devez supporter IE, il y a bien sûr <a href="http://babeljs.io/">Babel</a>
ou les nombreuses implémentations utilisateur.</li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/object-assign/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/object-assign/</guid><pubDate>Fri, 04 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015: default values for arguments]]></title><description><![CDATA[<p>Tired of typing <code>if (typeof x === 'undefined') x = defaultValue</code>? Again, ES6
will brings us a elegant solution.</p>
<h1 id="default-values"><a class="markdownIt-Anchor" href="#default-values">#</a> Default values</h1>
<p>The <code>=</code> operator can now help to define a default value to a parameter.</p>
<h2 id="function-parameters"><a class="markdownIt-Anchor" href="#function-parameters">#</a> Function parameters</h2>
<p>You can now specify a default value for a parameter of a function.
This value will be used if the parameter is not defined, or explicitly set to
<em>undefined</em>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incr</span> (<span class="hljs-params">value, step = 1</span>) </span>{
  <span class="hljs-keyword">return</span> value + step
}

incr(<span class="hljs-number">41</span>) <span class="hljs-comment">// 42</span>
incr(<span class="hljs-number">41</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 42</span>
incr(<span class="hljs-number">33</span>, <span class="hljs-number">9</span>) <span class="hljs-comment">// 42</span></code></pre>
<h3 id="dynamic-default-values"><a class="markdownIt-Anchor" href="#dynamic-default-values">#</a> Dynamic default values</h3>
<p>We can specify an expression as a default value.
This expression will be evalued <strong>during the function call</strong>, not during the
function declaration.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> defaultWho = <span class="hljs-string">'world!'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span> (<span class="hljs-params">who = defaultWho.toUpperCase(</span>)) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + who
}

hello() <span class="hljs-comment">// 'Hello WORLD!'</span>
defaultWho = <span class="hljs-string">'Anyone?'</span>
hello() <span class="hljs-comment">// 'Hello ANYONE?'</span></code></pre>
<h3 id="reusing-previous-parameters"><a class="markdownIt-Anchor" href="#reusing-previous-parameters">#</a> Reusing previous parameters</h3>
<p>In the default value expression, you can reuse <strong>previous</strong> function parameters:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = 1, y = x + 1</span>) </span>{
  <span class="hljs-keyword">return</span> x + y
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params">x = y + 1, y = 1</span>) </span>{
  <span class="hljs-keyword">return</span> x + y
}

foo() <span class="hljs-comment">// 1 + (1 + 1) → 3</span>
bar() <span class="hljs-comment">// (undefined + 1) + 1 → NaN</span></code></pre>
<h3 id="particular-case-tdz-temporal-dead-zone"><a class="markdownIt-Anchor" href="#particular-case-tdz-temporal-dead-zone">#</a> Particular case: TDZ (Temporal Dead Zone)</h3>
<p>A temporal dead zone is an area of your program where a variable exists, but is
not available yet while it didn’t get its value.</p>
<p>The following example is obviously invalid:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = x</span>) </span>{ <span class="hljs-comment">// throws ReferenceError?</span>
}</code></pre>
<p>In fact, during the call of the function, <code>x</code> has not been defined yet,
so it cannot be used as a default value.
This example should trigger an
<a href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters">error</a></p>
<p>However, scope rules will make this example invalid:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = x</span>) </span>{ <span class="hljs-comment">// 'x' used here is the parameter itself</span>
}</code></pre>
<p>After the evaluation of the default values, we are in the scope of the function
and in this scope, <code>x</code> corresponds to the parameter (not defined yet) and not
the value defined above.</p>
<p><strong>ProTip: do not reuse a variable name 3 times</strong>
(that might helps to read and understand your code).</p>
<h2 id="destructuring"><a class="markdownIt-Anchor" href="#destructuring">#</a> Destructuring</h2>
<p>Like for the function arguments, assignments using
<a href="/en/articles/js/es2015/destructuring/">destructuring</a>
can have a default value.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {z: <span class="hljs-number">42</span>} 
<span class="hljs-keyword">const</span> { x = <span class="hljs-number">1</span>, y = x + <span class="hljs-number">1</span>, z, w } = obj
w <span class="hljs-comment">// undefined</span>
x <span class="hljs-comment">// 1</span>
y <span class="hljs-comment">// 2</span>
z <span class="hljs-comment">// 42</span></code></pre>
<p>As a reminder, the assignation in the previous example would have been written
this way using ES5:</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> x = (obj.x === <span class="hljs-literal">undefined</span>) ? <span class="hljs-number">1</span> : obj.x 
<span class="hljs-keyword">var</span> y = (obj.y === <span class="hljs-literal">undefined</span>) ? x + <span class="hljs-number">1</span> : obj.y 
<span class="hljs-keyword">var</span> z = obj.z
<span class="hljs-keyword">var</span> w = obj.w</code></pre>
<h1 id="enjoy"><a class="markdownIt-Anchor" href="#enjoy">#</a> Enjoy!</h1>
<p>There is no more reasons <em>a priori</em> to see an <code>undefined</code> in an ES6 codebase.</p>
<p>About the compatibility (at the time of the writing): only Firefox ≥ 43
support this feature (and just for function…).
So you will need <a href="http://babeljs.io">Babel</a> or Traceur to be able to use it.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/defaults/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/defaults/</guid><pubDate>Thu, 03 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les valeurs par défaut des arguments]]></title><description><![CDATA[<p>Fatigués de taper <code>if (typeof x === 'undefined') x = defaultValue</code> ? Là encore
ES6 va nous apporter une solution élégante.</p>
<h1 id="valeurs-par-d-faut"><a class="markdownIt-Anchor" href="#valeurs-par-d-faut">#</a> Valeurs par défaut</h1>
<p>L’opérateur <code>=</code> permet maintenant en plus d’affecter une valeur à une variable
de définir une valeur par défaut à un paramètre.</p>
<h2 id="param-tres-de-fonction"><a class="markdownIt-Anchor" href="#param-tres-de-fonction">#</a> Paramètres de fonction</h2>
<p>Il est maintenant possible de spécifier une valeur par défaut à un paramètre de
fonction. Cette valeur sera utilisée si le paramètre n’est pas fourni, ou qu’il
est explicitement défini à <em>undefined</em>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incr</span> (<span class="hljs-params">value, step = 1</span>) </span>{
  <span class="hljs-keyword">return</span> value + step
}

incr(<span class="hljs-number">41</span>) <span class="hljs-comment">// 42</span>
incr(<span class="hljs-number">41</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 42</span>
incr(<span class="hljs-number">33</span>, <span class="hljs-number">9</span>) <span class="hljs-comment">// 42</span></code></pre>
<h3 id="valeurs-par-d-faut-dynamiques"><a class="markdownIt-Anchor" href="#valeurs-par-d-faut-dynamiques">#</a> Valeurs par défaut dynamiques</h3>
<p>On peut spécifier une expression en tant que valeur par défaut. Cette expression
sera évaluée <strong>à l’appel de la fonction</strong>, pas lors de sa déclaration.</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> defaultWho = <span class="hljs-string">'world!'</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span> (<span class="hljs-params">who = defaultWho.toUpperCase(</span>)) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello '</span> + who
}

hello() <span class="hljs-comment">// 'Hello WORLD!'</span>
defaultWho = <span class="hljs-string">'Anyone?'</span>
hello() <span class="hljs-comment">// 'Hello ANYONE?'</span></code></pre>
<h3 id="r-utilisation-des-param-tres-pr-c-dents"><a class="markdownIt-Anchor" href="#r-utilisation-des-param-tres-pr-c-dents">#</a> Réutilisation des paramètres précédents</h3>
<p>Dans l’expression d’une valeur par défaut, on peut réutiliser les paramètres
<strong>précédents</strong> de la fonction :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = 1, y = x + 1</span>) </span>{
  <span class="hljs-keyword">return</span> x + y
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params">x = y + 1, y = 1</span>) </span>{
  <span class="hljs-keyword">return</span> x + y
}

foo() <span class="hljs-comment">// 1 + (1 + 1) → 3</span>
bar() <span class="hljs-comment">// (undefined + 1) + 1 → NaN</span></code></pre>
<h3 id="cas-particulier-tdz-temporal-dead-zone"><a class="markdownIt-Anchor" href="#cas-particulier-tdz-temporal-dead-zone">#</a> Cas particulier : TDZ (Temporal Dead Zone)</h3>
<p>Une <em>temporal dead zone</em> désigne une zone du programme où une variable “existe”
mais n’est pas encore accessible tant qu’elle n’a pas reçu de valeur.</p>
<p>L’exemple suivant semble très logiquement invalide :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = x</span>) </span>{ <span class="hljs-comment">// throws ReferenceError?</span>
}</code></pre>
<p>En effet, au moment de l’appel à la fonction, <code>x</code> n’a pas encore été défini,
et ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple
devrait <a href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters">lever une erreur</a>.</p>
<p>Néanmoins, les règles de portée font que ce programme est également invalide :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x = x</span>) </span>{ <span class="hljs-comment">// Le 'x' référencé ici est le paramètre</span>
}</code></pre>
<p>On est bien, dès l’évaluation des valeurs par défaut, dans le scope de la
fonction, et dans ce scope <code>x</code> fait référence au paramètre (pas encore défini)
et pas à la variable du dessus.</p>
<p><strong>ProTip:  ne réutilisez pas 3 fois le même nom de variable</strong>
(ça pourra aussi aider à la compréhension).</p>
<h2 id="d-composition"><a class="markdownIt-Anchor" href="#d-composition">#</a> Décomposition</h2>
<p>De la même manière que pour les paramètres de fonction, les affectations par
décomposition
(<a href="/fr/articles/js/es2015/destructuring/">destructuring</a>)
peuvent bénéficier de valeurs par défaut.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {z: <span class="hljs-number">42</span>} 
<span class="hljs-keyword">const</span> { x = <span class="hljs-number">1</span>, y = x + <span class="hljs-number">1</span>, z, w } = obj
w <span class="hljs-comment">// undefined</span>
x <span class="hljs-comment">// 1</span>
y <span class="hljs-comment">// 2</span>
z <span class="hljs-comment">// 42</span></code></pre>
<p>Pour rappel, l’affectation de l’exemple précédent aurait été écrit de cette
manière en ES5 :</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> x = (obj.x === <span class="hljs-literal">undefined</span>) ? <span class="hljs-number">1</span> : obj.x 
<span class="hljs-keyword">var</span> y = (obj.y === <span class="hljs-literal">undefined</span>) ?  x + <span class="hljs-number">1</span> : obj.y
<span class="hljs-keyword">var</span> z = obj.z
<span class="hljs-keyword">var</span> w = obj.w</code></pre>
<h1 id="enjoy"><a class="markdownIt-Anchor" href="#enjoy">#</a> Enjoy!</h1>
<p>Il n’y a <em>a priori</em> plus aucune raison de croiser un test sur <code>undefined</code> dans
votre code une fois passé à ES6.</p>
<p>Un petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43
implémente les valeurs par défaut, et encore seulement pour les paramètres de
fonctions.
Il faudra donc utiliser <a href="http://babeljs.io">Babel</a> ou Traceur pour en profiter.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/defaults/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/defaults/</guid><pubDate>Thu, 03 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : the destructuring]]></title><description><![CDATA[<p>The destructuring is a feature that helps you assign variables from an object or
an array based on their structure.</p>
<pre><code class="language-js"><span class="hljs-comment">// Let's consider this object `myObject`</span>
<span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>,
}

<span class="hljs-comment">// With ES5, you need to do</span>
<span class="hljs-keyword">var</span> foo = myObject.foo
<span class="hljs-keyword">var</span> bar = myObject.bar

foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// With ES6, you can write the same with</span>
<span class="hljs-keyword">const</span> { foo, bar } = myObject
foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// We can even destructure the value returned by a function (if this one</span>
<span class="hljs-comment">// returns a function or an array)</span>
<span class="hljs-keyword">const</span> getMyObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    foo: <span class="hljs-number">1</span>,
    bar: <span class="hljs-number">2</span>,
  }
}
<span class="hljs-keyword">const</span> { foo, bar } = getMyObject()
foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span></code></pre>
<h2 id="different-syntaxes"><a class="markdownIt-Anchor" href="#different-syntaxes">#</a> Different syntaxes</h2>
<h3 id="array"><a class="markdownIt-Anchor" href="#array">#</a> Array</h3>
<pre><code class="language-js"><span class="hljs-comment">// For an array, we can use a syntax that is similar to a literal declaration</span>
<span class="hljs-comment">// of an array</span>
<span class="hljs-comment">// You might notice that you can ignore an item by just put nothing between the</span>
<span class="hljs-comment">// commas</span>
<span class="hljs-keyword">const</span> [ first, second, , fourth ] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
first <span class="hljs-comment">// 1</span>
second <span class="hljs-comment">// 2</span>
fourth <span class="hljs-comment">// 4</span></code></pre>
<h3 id="use-a-different-name-for-the-key"><a class="markdownIt-Anchor" href="#use-a-different-name-for-the-key">#</a> Use a different name for the key</h3>
<p>For an object, the default behavior is that the name of a variable will match
the name of the key.
So if you have already a variable with this name, you can choose another one.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>
}
<span class="hljs-keyword">const</span> { foo: renamedFoo } = myObject
renamedFoo <span class="hljs-comment">// 1</span></code></pre>
<p>This syntax doesn’t offer a good readability.</p>
<h3 id="function-arguments"><a class="markdownIt-Anchor" href="#function-arguments">#</a> Function arguments</h3>
<pre><code class="language-js"><span class="hljs-comment">// We can use destructuring directing in a function declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">{ title, text }</span>) </span>{
	<span class="hljs-keyword">return</span> title + <span class="hljs-string">": "</span> + text
}

myFunction({ title: <span class="hljs-string">"foo"</span>, text: <span class="hljs-string">"bar"</span> }) <span class="hljs-comment">// "foo: bar"</span></code></pre>
<h3 id="nested-destructuring"><a class="markdownIt-Anchor" href="#nested-destructuring">#</a> Nested destructuring</h3>
<p>We can also nest the assignments.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> myObject = {
  foo: {
    bar: <span class="hljs-number">1</span>,
  },
}
<span class="hljs-keyword">const</span> { foo: { bar } } = myObject
bar <span class="hljs-comment">// 1</span></code></pre>
<p>Be careful, if the destructuring of the first level should return <code>undefined</code>
(if the value doesn’t exist), be sure that you will have a nesting error, since
a value will try to be retrieved from an <code>undefined</code> property.
To prevent this issue, you will need to define
<a href="/en/articles/js/es2015/defaults/">defaults</a> values.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/destructuring/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/destructuring/</guid><pubDate>Wed, 02 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : le destructuring]]></title><description><![CDATA[<h2 id="le-principe"><a class="markdownIt-Anchor" href="#le-principe">#</a> Le principe</h2>
<p>Le destructuring consiste à assigner des variables provenant d’un objet ou
tableau en reposant sur leur structure.</p>
<pre><code class="language-js"><span class="hljs-comment">// Partons d'un objet `myObject`</span>
<span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>,
}

<span class="hljs-comment">// Avec ES5, vous deviez par exemple faire</span>
<span class="hljs-keyword">var</span> foo = myObject.foo
<span class="hljs-keyword">var</span> bar = myObject.bar

foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// Avec ES6, vous pouvez désormais l'écrire sous la forme</span>
<span class="hljs-keyword">const</span> { foo, bar } = myObject
foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// On peut bien entendu destructurer la valeur retournée par une</span>
<span class="hljs-comment">// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau</span>
<span class="hljs-keyword">const</span> getMyObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    foo: <span class="hljs-number">1</span>,
    bar: <span class="hljs-number">2</span>,
  }
}
<span class="hljs-keyword">const</span> { foo, bar } = getMyObject()
foo <span class="hljs-comment">// 1</span>
bar <span class="hljs-comment">// 2</span></code></pre>
<h2 id="les-diff-rentes-syntaxes"><a class="markdownIt-Anchor" href="#les-diff-rentes-syntaxes">#</a> Les différentes syntaxes</h2>
<h3 id="tableau"><a class="markdownIt-Anchor" href="#tableau">#</a> Tableau</h3>
<pre><code class="language-js"><span class="hljs-comment">// Pour un tableau, on utilise une forme proche de la déclaration litérale de</span>
<span class="hljs-comment">// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien</span>
<span class="hljs-comment">// placer entre les virgules</span>
<span class="hljs-keyword">const</span> [ first, second, , fourth ] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
first <span class="hljs-comment">// 1</span>
second <span class="hljs-comment">// 2</span>
fourth <span class="hljs-comment">// 4</span></code></pre>
<h3 id="utiliser-un-nom-diff-rent-de-la-cl"><a class="markdownIt-Anchor" href="#utiliser-un-nom-diff-rent-de-la-cl">#</a> Utiliser un nom différent de la clé</h3>
<p>Pour un objet, par défaut, le nom de la variable correspond au nom de la clé.
Si, par exemple, vous avez déjà une variable portant le nom de la clé dans le
scope, vous pouvez choisir de nommer différemment votre variable.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> myObject = {
  foo: <span class="hljs-number">1</span>,
  bar: <span class="hljs-number">2</span>
}
<span class="hljs-keyword">const</span> { foo: renamedFoo } = myObject
renamedFoo <span class="hljs-comment">// 1</span></code></pre>
<p>Cette syntaxe est, il faut tout de même le noter, peu lisible.</p>
<h3 id="arguments-de-fonctions"><a class="markdownIt-Anchor" href="#arguments-de-fonctions">#</a> Arguments de fonctions</h3>
<pre><code class="language-js"><span class="hljs-comment">// On peut directement utiliser le destructuring dans une déclaration de</span>
<span class="hljs-comment">// fonction</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">{ title, text }</span>) </span>{
	<span class="hljs-keyword">return</span> title + <span class="hljs-string">": "</span> + text
}

myFunction({ title: <span class="hljs-string">"foo"</span>, text: <span class="hljs-string">"bar"</span> }) <span class="hljs-comment">// "foo: bar"</span></code></pre>
<h3 id="nested-destructuring"><a class="markdownIt-Anchor" href="#nested-destructuring">#</a> Nested destructuring</h3>
<p>On peut aussi imbriquer les assignements.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> myObject = {
  foo: {
    bar: <span class="hljs-number">1</span>,
  },
}
<span class="hljs-keyword">const</span> { foo: { bar } } = myObject
bar <span class="hljs-comment">// 1</span></code></pre>
<p>Attention cependant, si le destructuring au premier niveau ne fera que retourner
<code>undefined</code> si la valeur n’existe pas, vous aurez bel et bien une erreur avec le
nesting, puisqu’il essaiera d’aller chercher une propriété d’<code>undefined</code>.
Pour pallier ces soucis, rendez-vous pour l’article sur les
<a href="/fr/articles/js/es2015/defaults/">defaults</a>.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/destructuring/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/destructuring/</guid><pubDate>Wed, 02 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : la déclaration de variables avec const, let et var]]></title><description><![CDATA[<p>ES6 (aussi appelé ES2015) vous apporte de nouvelles façons de déclarer vos
variables grâce à <code>let</code> et <code>const</code> mais garde aussi la déclaration par <code>var</code>
dans la spécification du langage.</p>
<p>Première étape, on oublie tout ce qu’on sait sur <code>var</code>.</p>
<h1 id="d-clarations"><a class="markdownIt-Anchor" href="#d-clarations">#</a> Déclarations</h1>
<h2 id="const"><a class="markdownIt-Anchor" href="#const">#</a> const</h2>
<p><code>const</code> vous permet de déclarer une variable à assignation unique bindée
lexicalement. Bon, ça fait un peu pompeux, alors pour les devs au fond de la
salle à côté du radiateur, ça veut simplement dire que vous pouvez déclarer une
variable qui ne contiendra qu’une valeur et qui sera scopée au niveau du bloc.</p>
<p>Si vous avez déjà lu des posts ou des ressources parlant de <code>const</code>, méfiez-vous
: ce ne sont pas des vraies constantes au sens <em>valeur</em> de variable. Ce sont des
constantes au niveau référence. C’est à dire que le contenu d’un tableau ou d’un
objet déclaré avec <code>const</code> bloque la réassignation de la variable, mais ne rend
pas la valeur immuable.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> foo = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> foo <span class="hljs-comment">// SyntaxError, la variable a besoin d'être assignée</span>
    <span class="hljs-keyword">const</span> foo = <span class="hljs-string">"qux"</span>
    foo = <span class="hljs-string">"norf"</span> <span class="hljs-comment">// SyntaxError, la variable ne peut pas être réassignée</span>
    <span class="hljs-built_in">console</span>.log(foo)
    <span class="hljs-comment">// "qux", la variable appartient au scope de son bloc (le "if")</span>
  }
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// "bar", la variable appartient au scope de la fonction "fn"</span>
}</code></pre>
<p>Le fonctionnement <code>const</code> peut être utilisé de manière cool dans le cas
d’itérables :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(el)
  }
}</code></pre>
<p>En effet, on pourrait croire qu’un <code>let</code> doit être utilisé ici, mais la
déclaration est évaluée à chaque passage de l’itérateur, <code>const</code> est donc un
meilleur choix !</p>
<h2 id="let"><a class="markdownIt-Anchor" href="#let">#</a> let</h2>
<p><code>let</code> vous permet de faire pareil que <code>const</code> mais sans la contrainte
d’assignation unique. Vous devriez donc instinctivement voir que les cas
d’utilisation pour <code>let</code> sont les mêmes que ceux de <code>var</code>, son ancêtre.
D’ailleurs, vous entendrez souvent : <code>let</code> est le nouveau <code>var</code> (<em><code>let</code> is the
new <code>var</code></em>). C’est en partie vrai car il est capable de faire les mêmes choses,
mais en mieux, car il a cette caractéristique d’être scopé au bloc courant.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">var</span> foo2 = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> foo <span class="hljs-comment">// pas d'erreur, foo === undefined</span>
    <span class="hljs-keyword">var</span> foo2
    <span class="hljs-comment">// Attention, les déclarations "var" ne sont pas scopées au niveau bloc</span>
    <span class="hljs-comment">// foo2 est en réalité écrasé !</span>
    foo = <span class="hljs-string">"qux"</span>
    foo2 = <span class="hljs-string">"qux"</span>
    <span class="hljs-built_in">console</span>.log(foo)
    <span class="hljs-comment">// "qux", la variable appartient au scope de son blocs (le "if")</span>
    <span class="hljs-built_in">console</span>.log(foo2)
    <span class="hljs-comment">// "qux"</span>
  }
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// "bar", la variable appartient au scope de son bloc (la fonction "fn")</span>
  <span class="hljs-built_in">console</span>.log(foo2)
  <span class="hljs-comment">// "qux"</span>
}</code></pre>
<p>Vous pouvez par exemple utiliser <code>let</code> pour vos boucles, la variable servant à
l’itération est désormais scopée au niveau de cette boucle et n’entrera pas en
conflit avec votre code autour. Plus de problème de <code>i</code> déjà pris !</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=i; i&lt;<span class="hljs-number">10</span>; i++) {
    <span class="hljs-built_in">console</span>.log(i)
  }
  <span class="hljs-built_in">console</span>.log(i)
  <span class="hljs-comment">// 0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=i; j&lt;<span class="hljs-number">10</span>; j++) {}
  <span class="hljs-built_in">console</span>.log(j)
  <span class="hljs-comment">// j is not defined</span>
}
fn2() <span class="hljs-comment">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>
<p>Note : l’exemple avec <code>const</code> dans une boucle <code>for ... of</code> ne peut être
reproduit ici. En effet, la boucle <code>for</code> classique est impérative, et la
déclaration n’est effectuée qu’une seule fois au début de la boucle. Un <code>const</code>
n’est donc pas utilisable.</p>
<h2 id="var"><a class="markdownIt-Anchor" href="#var">#</a> var</h2>
<p>On a vu <code>const</code>, on a vu <code>let</code>. Avec ces deux nouveaux outils, il ne reste pas
de grande place pour <code>var</code>. À mon avis, le seul cas d’utilisation valable pour
<code>var</code> est lors de l’utilisation de <code>try</code>/<code>catch</code>, et ce n’est pas dans le cadre
d’un bug, mais juste de syntaxe et de préférence
(<a href="https://twitter.com/getify/status/658662478528643072">exemple</a>).</p>
<h1 id="pi-ge-du-hoisting-et-de-la-tdz-temporal-dead-zone"><a class="markdownIt-Anchor" href="#pi-ge-du-hoisting-et-de-la-tdz-temporal-dead-zone">#</a> Piège du hoisting et de la TDZ (<em>Temporal Dead Zone</em>)</h1>
<p>Pour rappel, JavaScript possède un mécanisme de hoisting, par exemple, vous
pouvez écrire :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(foo) <span class="hljs-comment">// undefined (au lieu de ReferenceError)</span>
  <span class="hljs-keyword">var</span> foo = <span class="hljs-string">"bar"</span>
}</code></pre>
<p>Concrètement, le moteur d’exécution JavaScript va lire toutes les déclarations
et remonter celles avec <code>var</code> au début du scope de votre fonction (attention,
cela concerne les déclarations, pas les affectations).</p>
<p><code>let</code> et <code>const</code> ne bénéficient pas de ce mécanisme de hoisting, ce qui peut
mener à des problèmes de TDZ (<em>Temporal Dead Zone</em>). Vu que la déclaration de
votre variable n’est pas remontée au scope de la fonction, il existe un moment
où votre variable n’existe pas. Ce moment, c’est la TDZ.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// ReferenceError, on est dans la TDZ pour la variable foo</span>
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>
}</code></pre>
<h1 id="outro"><a class="markdownIt-Anchor" href="#outro">#</a> Outro</h1>
<p>Comment choisir quelle déclaration de variable utiliser ? C’est très simple :</p>
<ul>
<li>Utilisez une déclaration par <code>const</code> (99% du temps, c’est le bon choix)</li>
<li>Si au fil de votre code vous changez sa valeur, modifiez pour un <code>let</code> (1%)</li>
<li>Si vous avez trouvé le pire cas d’utilisation du monde, changez pour un <code>var</code>
(je vous laisse faire le calcul)</li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/const-let-var/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/const-let-var/</guid><pubDate>Tue, 01 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Avantages à diviser ses storyboards sur iOS/OS X]]></title><description><![CDATA[<p>Aujourd’hui, on va parler d’un sujet qui parle à tous les devs iOS : les
<strong>storyboards</strong>.</p>
<blockquote>
<p>Pour faire court :  les storyboards sont les fichiers d’interface sous iOS/OS X.
C’est là où vous placer vos <code>vues</code> dans vos <code>scenes</code>, vous les positionnez
entre elles, vous pouvez créer des interactions entre les <code>scenes</code> pour passer
de l’une à l’autre. C’est proche des XAML de Visual ou des Layouts d’Android,
mais avec la notion de relation entre les <code>scenes</code> en plus. Ça permet de créer
graphiquement et simplement le workflow de l’application.</p>
</blockquote>
<h2 id="pourquoi-d-couper-son-storyboard"><a class="markdownIt-Anchor" href="#pourquoi-d-couper-son-storyboard">#</a> Pourquoi découper son storyboard</h2>
<p>Pouvoir relier aussi facilement toutes les <code>scenes</code> dans un même storyboard,
c’est génial. Mais alors pourquoi les diviser ?</p>
<h3 id="viter-des-conflits"><a class="markdownIt-Anchor" href="#viter-des-conflits">#</a> Éviter des conflits</h3>
<p>Si vous travaillez à plusieurs, vous avez sûrement déjà rencontré des
conflits lors de merges où tout le monde a décidé d’éditer le <code>storyboard</code> en
même temps. Le storyboard est donc corrompu et le seul moyen de le récupérer
est de prendre celui de quelqu’un et refaire les changements ou de corriger les
sources en croisant les doigts. Accompagné de 4 L de café.<br>
Avec plusieurs <code>storyboards</code> : chacun bosse sur sa partie graphique. Si <em>Bob</em>
travaille sur les <em>vues de comptes</em> et <em>Joe</em> sur les <em>settings</em> de l’app,
chacun a un storyboard et ne change pas ceux des autres. Ça fait beaucoup moins
de chance d’avoir des conflits, voire aucun si tout le monde se met d’accord !</p>
<h3 id="les-gros-projets-plus-faciles-diter-comprendre"><a class="markdownIt-Anchor" href="#les-gros-projets-plus-faciles-diter-comprendre">#</a> Les gros projets plus faciles à éditer/comprendre</h3>
<p>Pour les gros projets, avec beaucoup de <code>scenes</code>, ranger ces <code>scenes</code> par
groupes dans différents <code>storyboards</code> peut être un bon moyen de s’y retrouver
facilement. Vous n’avez pas à dézoomer à chaque fois que vous voulez chercher
une <code>scene</code> à l’autre bout du storyboard.</p>
<h3 id="augmenter-la-vitesse-de-compilation"><a class="markdownIt-Anchor" href="#augmenter-la-vitesse-de-compilation">#</a> Augmenter la vitesse de compilation</h3>
<p>Recompiler tout le storyboard juste pour un label changé ça ne sert pas à
grand chose et certains <code>storyboards</code> peuvent être long à compiler. Donc moins
d’éléments vous avez à recompiler, plus vite ça ira.</p>
<h3 id="r-utilisation-de-code"><a class="markdownIt-Anchor" href="#r-utilisation-de-code">#</a> Réutilisation de code</h3>
<p>Imaginons que vous bossez dans une boîte qui fait souvent les mêmes apps
pour les clients, vous pouvez vous faire des petits storyboards que vous
réutiliserez et customiserez grâce aux contrôleurs (couleur, font, etc). Ça peut
faire gagner du temps, mais aussi beaucoup en perdre si vous en abusez ⚠️.</p>
<h2 id="comment-faire"><a class="markdownIt-Anchor" href="#comment-faire">#</a> Comment faire</h2>
<p>Rentrons dans le vif du sujet, le côté technique. En quelques lignes de code :</p>
<pre><code class="language-swift"><span class="hljs-comment">// *** Swift ***</span>
<span class="hljs-comment">// Aller chercher le storyboard</span>
<span class="hljs-keyword">let</span> storyboardSettings = <span class="hljs-type">UIStoryboard</span>(name: <span class="hljs-string">"settings"</span>, bundle: <span class="hljs-literal">nil</span>)
<span class="hljs-comment">// Aller chercher le contrôleur qui est dans le storybard</span>
<span class="hljs-keyword">let</span> controllerSettings =
storyboardSettings.instantiateViewControllerWithIdentifier(<span class="hljs-string">"settingsController"</span>)
<span class="hljs-comment">// Présenter</span>
<span class="hljs-keyword">self</span>.presentViewController(controllerSettings,animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)</code></pre>
<pre><code class="language-objc"><span class="hljs-comment">// *** Objective C ***</span>
<span class="hljs-comment">// Aller chercher le sotyboard</span>
<span class="hljs-built_in">UIStoryboard</span> * storyboardSettings = [<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@"settings"</span>
bundle:<span class="hljs-literal">nil</span>];
<span class="hljs-comment">// Aller chercher le contrôleur qui est dans le storybard</span>
<span class="hljs-built_in">UIViewController</span>* controllerSettings = [storyboardSettings
instantiateViewControllerWithIdentifier:<span class="hljs-string">@"settingsController"</span>];
<span class="hljs-comment">// Présenter</span>
[<span class="hljs-keyword">self</span> presentViewController:controllerSettings animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];</code></pre>
<p>Rien de plus simple ! Mais c’est bien connu, les développeurs iOS sont des
fainéants, alors il y a encore plus simple, sans taper une seule ligne de code :</p>
<ul>
<li>créez un nouveau storyboard pour votre <em>secteur</em>
(File→New→File→[OS]→User Interface),</li>
<li>ajoutez une <code>scene</code> (<code>UIViewController</code>), mettre l’une en <code>vue initial</code>
(sinon le compilateur n’aime pas),</li>
<li>nommez les <code>storyboardID</code> de chacune de ces <code>scenes</code> dans le menu
<code>Utilies&gt;Identity Inspector</code>,</li>
<li>dans votre storyboard original, dans le menu <code>Utilies&gt;Object Library</code> cherchez
<code>storyboard</code> et ajoutez une <strong><code>Storyboard References</code></strong>,</li>
<li>sur la référence dans <code>Utilises&gt;Attributes Inspector</code> rentrez le nom dans
votre storyboard (dans <em>storyboard</em>) et remplissez <em>Reference ID</em> avec le
<em>storyboardID</em> de la <code>scene</code>,</li>
<li>pour finir, ajoutez une <code>segue</code>, à partir d’un bouton (par exemple) vers les
<em>Storyboard Reference</em> voulus.</li>
</ul>
<p>Plus long à lire qu’à faire !</p>
]]></description><link>http://putaindecode.io/fr/articles/xcode/storyboards/diviser/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/xcode/storyboards/diviser/</guid><pubDate>Tue, 01 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015: declaring variables with const, let and var]]></title><description><![CDATA[<p>ES6 (also known as ES2015) brings you new ways to declare your variables thanks
to <code>let</code> and <code>const</code>, but also keeps <code>var</code> in the language specification.</p>
<p>The first thing you need to do: forget everything you know about <code>var</code>.</p>
<h1 id="declarations"><a class="markdownIt-Anchor" href="#declarations">#</a> Declarations</h1>
<h2 id="const"><a class="markdownIt-Anchor" href="#const">#</a> const</h2>
<p><code>const</code> allows you to declare a single assignment variable lexically bound.
Sounds posh right? That just means that you can only assign once a value in a
variable, scoped at the block level.</p>
<p>If you have already read stuff about <code>const</code>, be careful: this is not a way to
declare immutable variables. Only the assigned reference is immutable, not the
value. This means that the content of an array or an object declared using
<code>const</code> can evolve but the re-assignment of the reference is impossible.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> foo = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> foo <span class="hljs-comment">// SyntaxError, variable needs to be assigned to something</span>
    <span class="hljs-keyword">const</span> foo = <span class="hljs-string">"qux"</span>
    foo = <span class="hljs-string">"norf"</span> <span class="hljs-comment">// SyntaxError, variable cannot be re-assigned</span>
    <span class="hljs-built_in">console</span>.log(foo)
    <span class="hljs-comment">// "qux", variable belongs to the scope of the current block (the "if" one)</span>
  }
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// "bar", variable belongs to the scope of the "fn" function</span>
}</code></pre>
<p>Just a fancy trick using <code>const</code> with an iterator:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(el)
  }
}</code></pre>
<p>You might think a <code>let</code> should be used here but the declaration is evaluated
on each iteration, so <code>const</code> fits better here.</p>
<h2 id="let"><a class="markdownIt-Anchor" href="#let">#</a> let</h2>
<p><code>let</code> allows you to do the same as <code>const</code> without the single assignment
constraint. So you can understand here that the use-cases are the same as for
its ancestor, <code>var</code>.
By the way, you might have been told that <em><code>let</code> is the new <code>var</code></em>.
It is partly true because it can do the same, but even better if we consider
the ability of the variable to be scoped to the block level.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">var</span> foo2 = <span class="hljs-string">"bar"</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> foo <span class="hljs-comment">// that's ok (foo === undefined)</span>
    <span class="hljs-keyword">var</span> foo2
    <span class="hljs-comment">// Be careful, `var` statements are not scoped to the block level</span>
    <span class="hljs-comment">// so previous foo2 is overwritten!</span>
    foo = <span class="hljs-string">"qux"</span>
    foo2 = <span class="hljs-string">"qux"</span>
    <span class="hljs-built_in">console</span>.log(foo)
    <span class="hljs-comment">// "qux", variable belongs to the scope of the current block (the "if" one)</span>
    <span class="hljs-built_in">console</span>.log(foo2)
    <span class="hljs-comment">// "qux"</span>
  }
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// "bar", variable belongs to the scope of its block (the "fn" function)</span>
  <span class="hljs-built_in">console</span>.log(foo2)
  <span class="hljs-comment">// "qux"</span>
}</code></pre>
<p>You can use <code>let</code> in loops, the variable used for the iteration will be scoped
to the block of the loop, not the (parent) scope of the code that contains the
loop. This resolves any issues that you may have had with <code>i</code> already defined in
the upper scope!</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=i; i&lt;<span class="hljs-number">10</span>; i++) {
    <span class="hljs-built_in">console</span>.log(i)
  }
  <span class="hljs-built_in">console</span>.log(i)
  <span class="hljs-comment">// 0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=i; j&lt;<span class="hljs-number">10</span>; j++) {}
  <span class="hljs-built_in">console</span>.log(j)
  <span class="hljs-comment">// j is not defined</span>
}
fn2() <span class="hljs-comment">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>
<p>Note: the example with <code>const</code> used in the <code>for ... of</code> loop cannot be
reproduced here.
The classic <code>for</code> loop is imperative, and the declaration is only made once when
the loop starts. <code>const</code> is not relevant in this case.</p>
<h2 id="var"><a class="markdownIt-Anchor" href="#var">#</a> var</h2>
<p>With <code>const</code> and <code>let</code>, there is no more space for <code>var</code> anymore.
<a href="https://twitter.com/getify/status/658662478528643072">Maybe in a <code>try</code>/<code>catch</code>
context</a>.</p>
<h1 id="hoisting-and-tdz-temporal-dead-zone-issues"><a class="markdownIt-Anchor" href="#hoisting-and-tdz-temporal-dead-zone-issues">#</a> Hoisting and TDZ (Temporal Dead Zone) issues</h1>
<p>As a reminder, JavaScript does have a hoisting mechanism. For example, you can
write:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(foo) <span class="hljs-comment">// undefined (no ReferenceError)</span>
  <span class="hljs-keyword">var</span> foo = <span class="hljs-string">"bar"</span>
}</code></pre>
<p>JavaScript engine will read all <code>var</code> declarations and virtually move those at
the start of your function scope.</p>
<p><code>let</code> and <code>const</code> do not benefit from variable hoisting, and therefore can
create TDZ (Temporal Dead Zone) issues; these occur when a variable does not
exist yet.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(foo)
  <span class="hljs-comment">// ReferenceError, we are in the TDZ of "foo"</span>
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>
}</code></pre>
<h1 id="outro"><a class="markdownIt-Anchor" href="#outro">#</a> Outro</h1>
<p>So, let’s recap:</p>
<ul>
<li>Use <code>const</code> (might be relevant 99% of the time)</li>
<li>If during you development you happen to have to change the value of this
variable, switch to <code>let</code> (that might happen 1% of the time)</li>
<li>If you are in the worst use-case of the world, use <code>var</code> (you can do the math)</li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/const-let-var/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/const-let-var/</guid><pubDate>Tue, 01 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Tester unitairement des composants React]]></title><description><![CDATA[<p>L’équipe de React a implémenté une fonctionnalité appelée
<a href="http://facebook.github.io/react/docs/test-utils.html#shallow-rendering">shallow rendering</a>
(rendu peu profond),
qui permet de rendre un composant avec un seul niveau de profondeur de rendu.</p>
<p>Cela permet du coup de vérifier ce que le rendu retourne sans avoir à se
soucier du comportement des composants enfants, qui ne sont pas instanciés ni
rendus. Cela ne nécessite pas de DOM.</p>
<p>Intéressant, n’est-ce pas ? Et d’ailleurs, le <em>shallow rendering</em> est
actuellement
<a href="https://discuss.reactjs.org/t/whats-the-prefered-way-to-test-react-js-components/26">la méthode recommandée pour tester vos composants React</a>.</p>
<p>Comme vous pourrez le voir dans un article listé à la fin de celui-ci,
le code permettant de tester des composants avec cette technique n’est pas
forcément très concis, contrairement à ce qu’on pourrait attendre.</p>
<p>Heureusement, <a href="https://github.com/vvo">quelqu’un</a> a codé un truc plutôt cool :
<a href="https://github.com/algolia/react-element-to-jsx-string">react-element-to-jsx-string</a>.
Comme le nom l’indique, cette librairie permet de rendre un composant React en
tant que chaîne JSX.</p>
<p>C’est maintenant les choses deviennent intéressantes :
avec ces concepts en tête (le shallow render et le rendu de composant en strings
JSX), on peut facilement ajouter de simple tests unitaires sur ses composants.</p>
<p><em>Il y a d’autres techniques pour tester des composants React, et la plupart
implique le DOM. Vous devrez donc éxecuter vos tests dans un navigateur (ou
en utilisant jsdom) : vos tests seront plus lents que la technique qui va suivre
(qui pour le coup est plus du vrai test unitaire, dans le sens où vous utilisez
moins de code et ne nécessitez pas un gros environnement).</em></p>
<h2 id="tester-facilement-des-composants-react-sans-dom"><a class="markdownIt-Anchor" href="#tester-facilement-des-composants-react-sans-dom">#</a> Tester facilement des composants React (sans DOM)</h2>
<p>On va partir avec ce simple composant :</p>
<pre><code class="language-js"><span class="hljs-comment">// web_modules/Picture/index.js</span>

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> { PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>

const Component = ({
  img,
  title,
  Loader,
  Title,
}) =&gt; (
  &lt;div&gt;
    {
      (!img || !img.src) &amp;&amp; Loader &amp;&amp;
      &lt;Loader /&gt;
    }
    {
      img &amp;&amp; img.src &amp;&amp;
      &lt;img src={ img.src } alt={ img.alt }/&gt;
    }
    {
      title &amp;&amp; Title &amp;&amp;
      &lt;Title text={ title } /&gt;
    }
  &lt;/div&gt;
)

Component.propTypes = {
  img: PropTypes.object,
  title: PropTypes.string,
  Loader: PropTypes.func.isRequired,
  Title: PropTypes.func.isRequired,
}

Component.displayName = <span class="hljs-string">"Picture"</span>

export default Component</code></pre>
<p>Ce composant affiche une image avec un composant pour le titre.
Si les données de l’image ne sont pas prêtes, on peut afficher un composant pour
indiquer le chargement.</p>
<p>Écrivons maintenant un petit test. Pour notre exemple, on va utiliser
<a href="https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4">tape</a>
couplé avec <a href="https://github.com/atabel/tape-jsx-equals">tape-jsx-equals</a>,
mais vous n’aurez pas de mal à trouver un paquet à
<a href="https://www.npmjs.com/search?q=expect+jsx">votre sauce sur npm</a>.</p>
<pre><code class="language-js"><span class="hljs-comment">// web_modules/Picture/__tests__/index.js</span>

<span class="hljs-keyword">import</span> tape <span class="hljs-keyword">from</span> <span class="hljs-string">"tape"</span>
<span class="hljs-keyword">import</span> addAssertions <span class="hljs-keyword">from</span> <span class="hljs-string">"extend-tape"</span>
<span class="hljs-keyword">import</span> jsxEquals <span class="hljs-keyword">from</span> <span class="hljs-string">"tape-jsx-equals"</span>
const test = addAssertions(tape, { jsxEquals })

<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>
<span class="hljs-keyword">import</span> { createRenderer } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-addons-test-utils"</span>

<span class="hljs-keyword">import</span> Picture <span class="hljs-keyword">from</span> <span class="hljs-string">".."</span>

// fixtures (empty and stateless react components)
const Loader = () =&gt; {}
const Title = () =&gt; {}

test(<span class="hljs-string">"PageContainer is properly rendered"</span>, (t) =&gt; {
  const renderer = createRenderer()

  renderer.render(
    &lt;Picture
      Loader={ Loader }
      Title={ Title }
    /&gt;
  )
  t.jsxEquals(
    renderer.getRenderOutput(),
    &lt;div&gt;
      &lt;Loader /&gt;
    &lt;/div&gt;,
    <span class="hljs-string">"can render a Loader component if no image data are passed"</span>
  )

  renderer.render(
    &lt;Picture
      Loader={ Loader }
      Title={ Title }
      img={ {
        src: <span class="hljs-string">"SRC"</span>,
        alt: <span class="hljs-string">"ALT"</span>,
      } }
    /&gt;
  )
  t.jsxEquals(
    renderer.getRenderOutput(),
    &lt;div&gt;
      &lt;img src=<span class="hljs-string">"SRC"</span> alt=<span class="hljs-string">"ALT"</span> /&gt;
    &lt;/div&gt;,
    <span class="hljs-string">"should render an image if data are passed"</span>
  )

  renderer.render(
    &lt;Picture
      Loader={ Loader }
      Title={ Title }
      img={ {
        src: <span class="hljs-string">"SRC"</span>,
        alt: <span class="hljs-string">"ALT"</span>,
      } }
      title={ <span class="hljs-string">"TITLE"</span> }
    /&gt;
  )
  t.jsxEquals(
    renderer.getRenderOutput(),
    &lt;div&gt;
      &lt;img src=<span class="hljs-string">"SRC"</span> alt=<span class="hljs-string">"ALT"</span> /&gt;
      &lt;Title text=<span class="hljs-string">"TITLE"</span> /&gt;
    &lt;/div&gt;,
    <span class="hljs-string">"can render a Title if data are passed"</span>
  )

  t.end()
})</code></pre>
<p>Ces tests sont une couverture minimale pour vous assurer que vous ne cassez rien
lorsque vous travaillez sur votre composant.</p>
<p>Comme vous pouvez le constater, les tests sont assez simples à écrire et vont
droit au but.
<strong>Ce qui est intéressant ici, c’est que nous ne comparons pas à l’aide de
simples chaînes. Nous utilisons directement des composants React.</strong></p>
<p>Vous pouvez tranquillement exécuter l’exemple complet et le récupérer depuis le
repository :</p>
<p><a href="https://github.com/MoOx/react-component-unit-testing-example">github.com/MoOx/react-component-unit-testing-example</a></p>
<p>Cet exemple contient les commandes et dépendances
(définies dans le <code>package.json</code>)
dont vous aurez besoin.</p>
<h1 id="et-comment-tester-les-v-nements-comme-onclick"><a class="markdownIt-Anchor" href="#et-comment-tester-les-v-nements-comme-onclick">#</a> Et comment tester les évènements comme <code>onClick</code> ?</h1>
<p>Vous n’avez pas à reproduire le clic complètement.</p>
<p><strong>Vos tests n’ont pas besoin de vérifier que la prop <code>onClick</code> va bien être
exécutée lorsque vous cliquerez sur un élément du DOM.</strong>
<em>React couvre probablement cela dans sa suite de tests.</em></p>
<p>Ce que vous avez besoin de tester, c’est que la valeur que vous passez au
<code>onClick</code> fait bien ce que vous voulez.
En gros, si vous avez un bout de code qui ressemble à
<code>onClick={ yourCallback }</code>, vous n’avez tout simplement qu’à appeler directement
<code>yourCallback()</code> dans vos tests juste avant votre comparaison.
C’est bien assez !</p>
<p>Si vous voulez aller un peu plus loin, vous pouvez continuer par lire :</p>
<ul>
<li><a href="http://simonsmith.io/unit-testing-react-components-without-a-dom/"><em>Unit testing React components without a DOM</em></a>,
par Simon Smith, qui couvre le même sujet, sans la simplicité de la comparaison
JSX,</li>
<li><a href="https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/"><em>How we unit test React components using expect-jsx</em></a>
sur le blog d’Algolia, qui explique pourquoi ils ont choisi et créé les outils
pour cette approche.</li>
</ul>
<p>Avec ces exemples, nous espérons vraiment que vous n’aurez plus peur de tester
votre code et que vous n’hésiterez plus à couvrir tous vos composants React de
tests 😍.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/react/test-unitaires/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/react/test-unitaires/</guid><pubDate>Tue, 24 Nov 2015 00:00:00 GMT</pubDate></item></channel></rss>