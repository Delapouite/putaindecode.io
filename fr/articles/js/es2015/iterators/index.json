{"head":{"layout":"Post","comments":true,"date":"2015-12-08","title":"ES6, ES2015 : Le protocole d'itération","tags":["javascript","ES6","ES2015","iterators"],"authors":["ffesseler"]},"body":"<p>Imaginez un concept si important que si vous l’enleviez du langage, il faudrait\nen conséquence enlever le spread, le destructuring, les générateurs, le for…of\net bien d’autres. Ce concept, introduit dans l’ES6, est enfait un protocole :\nle protocole d’itération.</p>\n<p>Le principe est de définir une convention dans le langage, qui permet de\nstandardiser la façon dont des sources de données peuvent être traversées.</p>\n<p>Première bonne nouvelle, ce protocole est assez simple à comprendre et se base\nsur 2 “interfaces” (oui les guillemets c’est pour dire qu’on ne parle pas\nd’interface au sens technique, puisqu’elles n’existent pas en JS).</p>\n<p>La première interface, appelée <strong>Iterator</strong> permet à un objet de produire en\nséquence des valeurs. Un objet est un Iterator lorsqu’il implémente une\nfunction <code>next()</code> qui retourne un object avec 2 propriétés :</p>\n<ul>\n<li><code>value</code>: la valeur courante lors de l’itération</li>\n<li><code>done</code> : un booléen qui indique si on a atteint la fin de l’itération ou non</li>\n</ul>\n<p>Les appels successifs à la méthode <code>next()</code> d’un Iterator permettent donc de\ntraverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator\nretourné par un Array qui contiendrait 2 valeurs (“a” et “b”) :</p>\n<pre><code class=\"language-js\">iteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: \"a\", done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: \"b\", done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: undefined, done: true}</span></code></pre>\n<p>Mais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)\nÇa tombe bien, c’est le rôle de la seconde interface, appelée <strong>Iterable</strong>. Un\nobjet est Iterable s’il implémente une méthode particulière qui va retourner\nl’Iterator. Cette méthode particulière (appelée <em>@@iterator</em> dans la\nspécification) doit être définie en utilisant le symbole <code>[Symbol.iterator]</code>.\n(Les symboles seront expliqués dans un prochain article, pas de panique).</p>\n<p>En reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>];\n<span class=\"hljs-keyword\">var</span> iteratorArray = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]();\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: \"a\", done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: \"b\", done: false}</span>\niteratorArray.next();\n<span class=\"hljs-comment\">// -&gt; Object {value: undefined, done: true}</span></code></pre>\n<p>L’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array.\nIl n’est pas très utile en soi, en voici donc un autre qui va permettre de\nboucler sur les valeurs et les afficher :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>];\n<span class=\"hljs-keyword\">var</span> iterator = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]();\n\n<span class=\"hljs-keyword\">var</span> result = iterator.next();\n<span class=\"hljs-keyword\">while</span> (!result.done) {\n  <span class=\"hljs-built_in\">console</span>.log(result.value);\n  result = iterator.next();\n}\n<span class=\"hljs-comment\">// 'a'</span>\n<span class=\"hljs-comment\">// 'b'</span></code></pre>\n<p>De manière générale, quand un objet qui implémente le protocole d’itération est\ntraversé, sa méthode <em>@@iterator</em> est appelée (une seule fois donc) et l’Iterator\nretourné est utilisé pour boucler sur ses valeurs.</p>\n<h1 id=\"consommateurs-d-iterable\"><a class=\"markdownIt-Anchor\" href=\"#consommateurs-d-iterable\">#</a> Consommateurs d’Iterable</h1>\n<p>La deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent avantage de ce protocole :</p>\n<ul>\n<li>Certaines syntaxes s’attendent à recevoir des Iterable</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>];\n\n<span class=\"hljs-comment\">// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of » </span>\n<span class=\"hljs-comment\">// qui permet de boucler sur les valeurs des Iterable.</span>\n<span class=\"hljs-keyword\">for</span> (val <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(val);\n}\n\n<span class=\"hljs-comment\">// Le spread qui permet d'insérer facilement des valeurs dans un Array</span>\n<span class=\"hljs-comment\">// utilise également des Iterable</span>\n[<span class=\"hljs-string\">'0'</span>, ...arr, <span class=\"hljs-string\">'1'</span>] <span class=\"hljs-comment\">// 0, a, b, 1</span>\n\n<span class=\"hljs-comment\">// yield nécessite également des Iterable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">gen</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">yield</span>* arr;\n}\ngen().next(); <span class=\"hljs-comment\">// { value:\"a\", done:false }</span>\n\n<span class=\"hljs-comment\">// Le destructuring avec le pattern Array</span>\n<span class=\"hljs-keyword\">let</span> [x, y] = arr; <span class=\"hljs-comment\">// x = 'a',  y = \"b\"</span></code></pre>\n<ul>\n<li>Des API acceptent également des Iterable</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"b\"</span>];\n\n<span class=\"hljs-comment\">// Certains constructeurs acceptent des Iterable</span>\n\n<span class=\"hljs-comment\">// Set et Weakset</span>\n<span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(arr);\nset.has(<span class=\"hljs-string\">\"b\"</span>) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// Map et WeakMap</span>\n<span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(arr.entries()); <span class=\"hljs-comment\">// Attention, le constructeur attend un ensemble [clé, valeur]</span>\nmap.get(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 'a'</span>\n\n\n<span class=\"hljs-comment\">// Ou encore les API suivants :</span>\n\n<span class=\"hljs-built_in\">Array</span>.from(iterable); <span class=\"hljs-comment\">// transforme n'importe quel Iterable en Array.</span>\n<span class=\"hljs-built_in\">Promise</span>.all(iterableCollectionDePromises); <span class=\"hljs-comment\">// n'importe quel Iterable qui contient un ensemble de Promises</span>\n<span class=\"hljs-built_in\">Promise</span>.race(iterableCollectionDePromises); <span class=\"hljs-comment\">// idem</span></code></pre>\n<h1 id=\"built-in-iterable\"><a class=\"markdownIt-Anchor\" href=\"#built-in-iterable\">#</a> Built-in Iterable</h1>\n<p>Troisième bonne nouvelles, plusieurs objets du langage implémentent déjà ce protocole :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// évidemment les Array</span>\n<span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">\"l\"</span>, <span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"l\"</span>];\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// 'l'</span>\n    <span class=\"hljs-comment\">// 'o'</span>\n    <span class=\"hljs-comment\">// 'l'</span>\n}\n\n<span class=\"hljs-comment\">// les String</span>\n<span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">\"lol\"</span>;\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> str) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// 'l'</span>\n    <span class=\"hljs-comment\">// 'o'</span>\n    <span class=\"hljs-comment\">// 'l'</span>\n}\n\n<span class=\"hljs-comment\">// les Map et Set (mais PAS WeakMap et WeakSet)</span>\n<span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-string\">'l'</span>, <span class=\"hljs-number\">1</span>).set(<span class=\"hljs-string\">'o'</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// [\"l\", 1]</span>\n    <span class=\"hljs-comment\">// [\"o\", 2]</span>\n}\n<span class=\"hljs-keyword\">var</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>().add(<span class=\"hljs-string\">'l'</span>).add(<span class=\"hljs-string\">'o'</span>);\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// 'l'</span>\n    <span class=\"hljs-comment\">// 'o'</span>\n}\n\n<span class=\"hljs-comment\">// Les TypedArray que vous utilisez tous les jours</span>\n<span class=\"hljs-keyword\">var</span> int16 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>(<span class=\"hljs-number\">2</span>);\nint16[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> int16) {\n    <span class=\"hljs-built_in\">console</span>.log(v);\n    <span class=\"hljs-comment\">// 42</span>\n    <span class=\"hljs-comment\">// 0</span>\n}\n\n<span class=\"hljs-comment\">// Même l'objet spécial arguments (que vous</span>\n<span class=\"hljs-comment\">// ne devriez plus utilisé avec l'ES6) est un Iterable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>)\n</span>{\n    <span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">arguments</span>) {\n        <span class=\"hljs-built_in\">console</span>.log(v);\n        <span class=\"hljs-comment\">// 'l'</span>\n        <span class=\"hljs-comment\">// 'o'</span>\n        <span class=\"hljs-comment\">// 'l'</span>\n    }\n}\ntest(<span class=\"hljs-string\">'l'</span>, <span class=\"hljs-string\">'o'</span>, <span class=\"hljs-string\">'l'</span>);\n\n<span class=\"hljs-comment\">// Les NodeList retournés par l'API DOM également !</span>\n<span class=\"hljs-keyword\">var</span> matches = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">'div'</span>);\n<span class=\"hljs-keyword\">for</span> (m <span class=\"hljs-keyword\">of</span> matches) {\n    <span class=\"hljs-built_in\">console</span>.log(m);\n    <span class=\"hljs-comment\">// &lt;div id=\"topSection\"&gt;</span>\n    <span class=\"hljs-comment\">// &lt;div id=\"brandLogo\"&gt;</span>\n    <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n<p>Autre point : Array, TypedArray, Map, Set sont des Iterable mais définissent\naussi des méthodes qui retournent également des Iterable (Ca va, vous suivez\ntoujours ?) :</p>\n<ul>\n<li>entries() retourne un ensemble des clés/valeurs</li>\n<li>keys() retourne les clés</li>\n<li>values() retourne les valeurs</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">for</span> (cleVals <span class=\"hljs-keyword\">of</span> arr.entries()) {\n    <span class=\"hljs-built_in\">console</span>.log(cleVals);\n    <span class=\"hljs-comment\">// [0, \"l\"]</span>\n    <span class=\"hljs-comment\">// [1, \"o\"]</span>\n    <span class=\"hljs-comment\">// [2, \"l\"]</span>\n}</code></pre>\n<p>Détail important, Object n’est pas Iterable mais il n’est pas impossible de\nvoir apparaitre dans l’ES7 les méthodes entries(), keys() et values() sur\nObject. (cf : <a href=\"https://github.com/tc39/proposal-object-values-entries\">Proposition spec</a>)</p>\n<h1 id=\"conclusion\"><a class=\"markdownIt-Anchor\" href=\"#conclusion\">#</a> Conclusion</h1>\n<p>J’espère que cet article a bien illustré l’importance de ce protocole dans le\nlangage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent\ndéjà avantage de ce protocole mais il est au moins aussi important de noter que\ncela permet d’établir une convention sur laquelle des librairies externes peuvent\ns’appuyer.</p>\n<p>Elles peuvent le faire de 2 manières :</p>\n<ul>\n<li>En proposant des sources de données qui implémentent le protocole (ex:\nliste chaînée)</li>\n<li>En tant que consommateur du protocole (ex: un algorithme de tri)</li>\n</ul>\n<h1 id=\"un-dernier-verre-pour-la-route\"><a class=\"markdownIt-Anchor\" href=\"#un-dernier-verre-pour-la-route\">#</a> Un dernier verre pour la route</h1>\n<p>Les articles suivants vous permettront d’aller encore plus loin dans le sujet. Vous y\napprendrez notamment qu’un iterator peut retourner en option 2 autres méthodes,\nqu’un générateur est à la fois un Iterable et un Iterator, qu’un Iterable peut\nêtre infini ou encore des exemples d’implémentations divers et variés :</p>\n<ul>\n<li><a href=\"http://www.2ality.com/2015/02/es6-iteration.html\">Iterables and iterators in ECMAScript 6</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">Iteration Protocols</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">ES6 in depth : iterators and the for of loop</a></li>\n<li><a href=\"https://ponyfoo.com/articles/es6-iterators-in-depth\">ES6 iterators in depth</a></li>\n</ul>\n<p>La pratique restant le meilleur moyen de se former, le site\n<a href=\"http://es6katas.org/\">ES6 Katas</a> est très bien fait pour s’exercer.</p>\n","rawBody":"\nImaginez un concept si important que si vous l’enleviez du langage, il faudrait\nen conséquence enlever le spread, le destructuring, les générateurs, le for…of\net bien d’autres. Ce concept, introduit dans l’ES6, est enfait un protocole :\nle protocole d’itération.\n\nLe principe est de définir une convention dans le langage, qui permet de\nstandardiser la façon dont des sources de données peuvent être traversées.\n\nPremière bonne nouvelle, ce protocole est assez simple à comprendre et se base\nsur 2 \"interfaces\" (oui les guillemets c’est pour dire qu’on ne parle pas\nd’interface au sens technique, puisqu’elles n’existent pas en JS).\n\nLa première interface, appelée **Iterator** permet à un objet de produire en\nséquence des valeurs. Un objet est un Iterator lorsqu’il implémente une\nfunction ``next()`` qui retourne un object avec 2 propriétés :\n\n* ``value``: la valeur courante lors de l'itération\n* ``done`` : un booléen qui indique si on a atteint la fin de l’itération ou non\n\nLes appels successifs à la méthode ``next()`` d’un Iterator permettent donc de\ntraverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator\nretourné par un Array qui contiendrait 2 valeurs (\"a\" et \"b\") :\n\n```js\niteratorArray.next();\n// -> Object {value: \"a\", done: false}\niteratorArray.next();\n// -> Object {value: \"b\", done: false}\niteratorArray.next();\n// -> Object {value: undefined, done: true}\n```\n\nMais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)\nÇa tombe bien, c’est le rôle de la seconde interface, appelée **Iterable**. Un\nobjet est Iterable s’il implémente une méthode particulière qui va retourner\nl'Iterator. Cette méthode particulière (appelée *@@iterator* dans la\nspécification) doit être définie en utilisant le symbole ``[Symbol.iterator]``.\n(Les symboles seront expliqués dans un prochain article, pas de panique). \n\nEn reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array :\n\n```js\nvar arr = [\"a\", \"b\"];\nvar iteratorArray = arr[Symbol.iterator]();\niteratorArray.next();\n// -> Object {value: \"a\", done: false}\niteratorArray.next();\n// -> Object {value: \"b\", done: false}\niteratorArray.next();\n// -> Object {value: undefined, done: true}\n```\n\nL’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array.\nIl n’est pas très utile en soi, en voici donc un autre qui va permettre de\nboucler sur les valeurs et les afficher :\n\n```js\nvar arr = [\"a\", \"b\"];\nvar iterator = arr[Symbol.iterator]();\n\nvar result = iterator.next();\nwhile (!result.done) {\n  console.log(result.value);\n  result = iterator.next();\n}\n// 'a'\n// 'b'\n```\n\nDe manière générale, quand un objet qui implémente le protocole d’itération est\ntraversé, sa méthode *@@iterator* est appelée (une seule fois donc) et l’Iterator\nretourné est utilisé pour boucler sur ses valeurs.\n\n# Consommateurs d'Iterable\n\nLa deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent avantage de ce protocole :\n\n* Certaines syntaxes s’attendent à recevoir des Iterable\n\n```js\nvar arr = [\"a\", \"b\"];\n\n// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of » \n// qui permet de boucler sur les valeurs des Iterable.\nfor (val of arr) {\n    console.log(val);\n}\n\n// Le spread qui permet d'insérer facilement des valeurs dans un Array\n// utilise également des Iterable\n['0', ...arr, '1'] // 0, a, b, 1\n\n// yield nécessite également des Iterable\nfunction* gen(){\n  yield* arr;\n}\ngen().next(); // { value:\"a\", done:false }\n\n// Le destructuring avec le pattern Array\nlet [x, y] = arr; // x = 'a',  y = \"b\"\n```\n\n* Des API acceptent également des Iterable\n```js\nvar arr = [\"a\", \"b\", \"b\"];\n\n// Certains constructeurs acceptent des Iterable\n\n// Set et Weakset\nvar set = new Set(arr);\nset.has(\"b\") // true\n// Map et WeakMap\nvar map = new Map(arr.entries()); // Attention, le constructeur attend un ensemble [clé, valeur]\nmap.get(0) // 'a'\n\n\n// Ou encore les API suivants :\n\nArray.from(iterable); // transforme n'importe quel Iterable en Array.\nPromise.all(iterableCollectionDePromises); // n'importe quel Iterable qui contient un ensemble de Promises\nPromise.race(iterableCollectionDePromises); // idem\n```\n\n# Built-in Iterable\n\nTroisième bonne nouvelles, plusieurs objets du langage implémentent déjà ce protocole :\n```js\n// évidemment les Array\nvar arr = [\"l\", \"o\", \"l\"];\nfor (v of arr) {\n    console.log(v);\n    // 'l'\n    // 'o'\n    // 'l'\n}\n\n// les String\nvar str = \"lol\";\nfor (v of str) {\n    console.log(v);\n    // 'l'\n    // 'o'\n    // 'l'\n}\n\n// les Map et Set (mais PAS WeakMap et WeakSet)\nvar map = new Map().set('l', 1).set('o', 2);\nfor (v of map) {\n    console.log(v);\n    // [\"l\", 1]\n    // [\"o\", 2]\n}\nvar set = new Set().add('l').add('o');\nfor (v of map) {\n    console.log(v);\n    // 'l'\n    // 'o'\n}\n\n// Les TypedArray que vous utilisez tous les jours\nvar int16 = new Int16Array(2);\nint16[0] = 42;\nfor (v of int16) {\n    console.log(v);\n    // 42\n    // 0\n}\n\n// Même l'objet spécial arguments (que vous\n// ne devriez plus utilisé avec l'ES6) est un Iterable\nfunction test()\n{\n    for (v of arguments) {\n        console.log(v);\n        // 'l'\n        // 'o'\n        // 'l'\n    }\n}\ntest('l', 'o', 'l');\n\n// Les NodeList retournés par l'API DOM également !\nvar matches = document.querySelectorAll('div');\nfor (m of matches) {\n    console.log(m);\n    // <div id=\"topSection\">\n    // <div id=\"brandLogo\">\n    // ...\n}\n```\n\nAutre point : Array, TypedArray, Map, Set sont des Iterable mais définissent\naussi des méthodes qui retournent également des Iterable (Ca va, vous suivez\ntoujours ?) :\n- entries() retourne un ensemble des clés/valeurs\n- keys() retourne les clés\n- values() retourne les valeurs \n\n```js\nfor (cleVals of arr.entries()) {\n    console.log(cleVals);\n    // [0, \"l\"]\n    // [1, \"o\"]\n    // [2, \"l\"]\n}\n```\n\nDétail important, Object n'est pas Iterable mais il n'est pas impossible de\nvoir apparaitre dans l'ES7 les méthodes entries(), keys() et values() sur\nObject. (cf : [Proposition spec](https://github.com/tc39/proposal-object-values-entries))\n\n# Conclusion\n\nJ’espère que cet article a bien illustré l’importance de ce protocole dans le\nlangage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent\ndéjà avantage de ce protocole mais il est au moins aussi important de noter que\ncela permet d’établir une convention sur laquelle des librairies externes peuvent\ns’appuyer.\n\nElles peuvent le faire de 2 manières :\n* En proposant des sources de données qui implémentent le protocole (ex:\nliste chaînée)\n* En tant que consommateur du protocole (ex: un algorithme de tri)\n\n# Un dernier verre pour la route\n\nLes articles suivants vous permettront d'aller encore plus loin dans le sujet. Vous y\napprendrez notamment qu’un iterator peut retourner en option 2 autres méthodes,\nqu’un générateur est à la fois un Iterable et un Iterator, qu’un Iterable peut\nêtre infini ou encore des exemples d’implémentations divers et variés :\n\n* [Iterables and iterators in ECMAScript 6](http://www.2ality.com/2015/02/es6-iteration.html)\n* [Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)\n* [ES6 in depth : iterators and the for of loop](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [ES6 iterators in depth](https://ponyfoo.com/articles/es6-iterators-in-depth)\n\nLa pratique restant le meilleur moyen de se former, le site\n[ES6 Katas](http://es6katas.org/) est très bien fait pour s'exercer.\n","raw":"---\ndate: \"2015-12-08\"\ntitle: \"ES6, ES2015 : Le protocole d'itération\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\n  - iterators\nauthors:\n  - ffesseler\n---\n\nImaginez un concept si important que si vous l’enleviez du langage, il faudrait\nen conséquence enlever le spread, le destructuring, les générateurs, le for…of\net bien d’autres. Ce concept, introduit dans l’ES6, est enfait un protocole :\nle protocole d’itération.\n\nLe principe est de définir une convention dans le langage, qui permet de\nstandardiser la façon dont des sources de données peuvent être traversées.\n\nPremière bonne nouvelle, ce protocole est assez simple à comprendre et se base\nsur 2 \"interfaces\" (oui les guillemets c’est pour dire qu’on ne parle pas\nd’interface au sens technique, puisqu’elles n’existent pas en JS).\n\nLa première interface, appelée **Iterator** permet à un objet de produire en\nséquence des valeurs. Un objet est un Iterator lorsqu’il implémente une\nfunction ``next()`` qui retourne un object avec 2 propriétés :\n\n* ``value``: la valeur courante lors de l'itération\n* ``done`` : un booléen qui indique si on a atteint la fin de l’itération ou non\n\nLes appels successifs à la méthode ``next()`` d’un Iterator permettent donc de\ntraverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator\nretourné par un Array qui contiendrait 2 valeurs (\"a\" et \"b\") :\n\n```js\niteratorArray.next();\n// -> Object {value: \"a\", done: false}\niteratorArray.next();\n// -> Object {value: \"b\", done: false}\niteratorArray.next();\n// -> Object {value: undefined, done: true}\n```\n\nMais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)\nÇa tombe bien, c’est le rôle de la seconde interface, appelée **Iterable**. Un\nobjet est Iterable s’il implémente une méthode particulière qui va retourner\nl'Iterator. Cette méthode particulière (appelée *@@iterator* dans la\nspécification) doit être définie en utilisant le symbole ``[Symbol.iterator]``.\n(Les symboles seront expliqués dans un prochain article, pas de panique). \n\nEn reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array :\n\n```js\nvar arr = [\"a\", \"b\"];\nvar iteratorArray = arr[Symbol.iterator]();\niteratorArray.next();\n// -> Object {value: \"a\", done: false}\niteratorArray.next();\n// -> Object {value: \"b\", done: false}\niteratorArray.next();\n// -> Object {value: undefined, done: true}\n```\n\nL’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array.\nIl n’est pas très utile en soi, en voici donc un autre qui va permettre de\nboucler sur les valeurs et les afficher :\n\n```js\nvar arr = [\"a\", \"b\"];\nvar iterator = arr[Symbol.iterator]();\n\nvar result = iterator.next();\nwhile (!result.done) {\n  console.log(result.value);\n  result = iterator.next();\n}\n// 'a'\n// 'b'\n```\n\nDe manière générale, quand un objet qui implémente le protocole d’itération est\ntraversé, sa méthode *@@iterator* est appelée (une seule fois donc) et l’Iterator\nretourné est utilisé pour boucler sur ses valeurs.\n\n# Consommateurs d'Iterable\n\nLa deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent avantage de ce protocole :\n\n* Certaines syntaxes s’attendent à recevoir des Iterable\n\n```js\nvar arr = [\"a\", \"b\"];\n\n// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of » \n// qui permet de boucler sur les valeurs des Iterable.\nfor (val of arr) {\n    console.log(val);\n}\n\n// Le spread qui permet d'insérer facilement des valeurs dans un Array\n// utilise également des Iterable\n['0', ...arr, '1'] // 0, a, b, 1\n\n// yield nécessite également des Iterable\nfunction* gen(){\n  yield* arr;\n}\ngen().next(); // { value:\"a\", done:false }\n\n// Le destructuring avec le pattern Array\nlet [x, y] = arr; // x = 'a',  y = \"b\"\n```\n\n* Des API acceptent également des Iterable\n```js\nvar arr = [\"a\", \"b\", \"b\"];\n\n// Certains constructeurs acceptent des Iterable\n\n// Set et Weakset\nvar set = new Set(arr);\nset.has(\"b\") // true\n// Map et WeakMap\nvar map = new Map(arr.entries()); // Attention, le constructeur attend un ensemble [clé, valeur]\nmap.get(0) // 'a'\n\n\n// Ou encore les API suivants :\n\nArray.from(iterable); // transforme n'importe quel Iterable en Array.\nPromise.all(iterableCollectionDePromises); // n'importe quel Iterable qui contient un ensemble de Promises\nPromise.race(iterableCollectionDePromises); // idem\n```\n\n# Built-in Iterable\n\nTroisième bonne nouvelles, plusieurs objets du langage implémentent déjà ce protocole :\n```js\n// évidemment les Array\nvar arr = [\"l\", \"o\", \"l\"];\nfor (v of arr) {\n    console.log(v);\n    // 'l'\n    // 'o'\n    // 'l'\n}\n\n// les String\nvar str = \"lol\";\nfor (v of str) {\n    console.log(v);\n    // 'l'\n    // 'o'\n    // 'l'\n}\n\n// les Map et Set (mais PAS WeakMap et WeakSet)\nvar map = new Map().set('l', 1).set('o', 2);\nfor (v of map) {\n    console.log(v);\n    // [\"l\", 1]\n    // [\"o\", 2]\n}\nvar set = new Set().add('l').add('o');\nfor (v of map) {\n    console.log(v);\n    // 'l'\n    // 'o'\n}\n\n// Les TypedArray que vous utilisez tous les jours\nvar int16 = new Int16Array(2);\nint16[0] = 42;\nfor (v of int16) {\n    console.log(v);\n    // 42\n    // 0\n}\n\n// Même l'objet spécial arguments (que vous\n// ne devriez plus utilisé avec l'ES6) est un Iterable\nfunction test()\n{\n    for (v of arguments) {\n        console.log(v);\n        // 'l'\n        // 'o'\n        // 'l'\n    }\n}\ntest('l', 'o', 'l');\n\n// Les NodeList retournés par l'API DOM également !\nvar matches = document.querySelectorAll('div');\nfor (m of matches) {\n    console.log(m);\n    // <div id=\"topSection\">\n    // <div id=\"brandLogo\">\n    // ...\n}\n```\n\nAutre point : Array, TypedArray, Map, Set sont des Iterable mais définissent\naussi des méthodes qui retournent également des Iterable (Ca va, vous suivez\ntoujours ?) :\n- entries() retourne un ensemble des clés/valeurs\n- keys() retourne les clés\n- values() retourne les valeurs \n\n```js\nfor (cleVals of arr.entries()) {\n    console.log(cleVals);\n    // [0, \"l\"]\n    // [1, \"o\"]\n    // [2, \"l\"]\n}\n```\n\nDétail important, Object n'est pas Iterable mais il n'est pas impossible de\nvoir apparaitre dans l'ES7 les méthodes entries(), keys() et values() sur\nObject. (cf : [Proposition spec](https://github.com/tc39/proposal-object-values-entries))\n\n# Conclusion\n\nJ’espère que cet article a bien illustré l’importance de ce protocole dans le\nlangage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent\ndéjà avantage de ce protocole mais il est au moins aussi important de noter que\ncela permet d’établir une convention sur laquelle des librairies externes peuvent\ns’appuyer.\n\nElles peuvent le faire de 2 manières :\n* En proposant des sources de données qui implémentent le protocole (ex:\nliste chaînée)\n* En tant que consommateur du protocole (ex: un algorithme de tri)\n\n# Un dernier verre pour la route\n\nLes articles suivants vous permettront d'aller encore plus loin dans le sujet. Vous y\napprendrez notamment qu’un iterator peut retourner en option 2 autres méthodes,\nqu’un générateur est à la fois un Iterable et un Iterator, qu’un Iterable peut\nêtre infini ou encore des exemples d’implémentations divers et variés :\n\n* [Iterables and iterators in ECMAScript 6](http://www.2ality.com/2015/02/es6-iteration.html)\n* [Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)\n* [ES6 in depth : iterators and the for of loop](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [ES6 iterators in depth](https://ponyfoo.com/articles/es6-iterators-in-depth)\n\nLa pratique restant le meilleur moyen de se former, le site\n[ES6 Katas](http://es6katas.org/) est très bien fait pour s'exercer.\n","__filename":"fr/articles/js/es2015/iterators.md","__url":"/fr/articles/js/es2015/iterators/"}