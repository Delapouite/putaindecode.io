{"head":{"layout":"Post","comments":true,"date":"2015-12-02","title":"ES6, ES2015 : le destructuring","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"]},"body":"<h2 id=\"le-principe\"><a class=\"markdownIt-Anchor\" href=\"#le-principe\">#</a> Le principe</h2>\n<p>Le destructuring consiste à assigner des variables provenant d’un objet ou tableau en reposant sur leur structure.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// partons d'un objet `myObject`</span>\n<span class=\"hljs-keyword\">var</span> myObject = {\n  foo: <span class=\"hljs-number\">1</span>,\n  bar: <span class=\"hljs-number\">2</span>,\n}\n\n<span class=\"hljs-comment\">// Avec ES5, vous deviez par exemple faire</span>\n<span class=\"hljs-keyword\">var</span> foo = myObject.foo\n<span class=\"hljs-keyword\">var</span> bar = myObject.bar\n\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// Avec ES6, vous pouvez désormais l'écrire sous la forme</span>\n<span class=\"hljs-keyword\">const</span> { foo, bar } = myObject\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// on peut bien entendu destructurer la valeur retournée par une</span>\n<span class=\"hljs-comment\">// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau</span>\n<span class=\"hljs-keyword\">const</span> getMyObject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    foo: <span class=\"hljs-number\">1</span>,\n    bar: <span class=\"hljs-number\">2</span>,\n  }\n}\n<span class=\"hljs-keyword\">const</span> { foo, bar } = getMyObject()\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span></code></pre>\n<h2 id=\"les-diff-rentes-syntaxes\"><a class=\"markdownIt-Anchor\" href=\"#les-diff-rentes-syntaxes\">#</a> Les différentes syntaxes</h2>\n<h3 id=\"tableau\"><a class=\"markdownIt-Anchor\" href=\"#tableau\">#</a> Tableau</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// pour un tableau, on utilise une forme proche de la déclaration litérale de tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien placer entre les virgules</span>\n<span class=\"hljs-keyword\">const</span> [ first, second, , fourth ] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\nfirst <span class=\"hljs-comment\">// 1</span>\nsecond <span class=\"hljs-comment\">// 2</span>\nfourth <span class=\"hljs-comment\">// 4</span></code></pre>\n<h3 id=\"utiliser-un-nom-diff-rent-de-la-cl\"><a class=\"markdownIt-Anchor\" href=\"#utiliser-un-nom-diff-rent-de-la-cl\">#</a> Utiliser un nom différent de la clé</h3>\n<p>Pour un objet, par défaut, le nom de la variable correspond au nom de la clé. Si, par exemple, vous avez déjà une variable portant le nom de la clé dans le scope, vous pouvez choisir de nommer différemment votre variable.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> myObject = {\n  foo: <span class=\"hljs-number\">1</span>,\n  bar: <span class=\"hljs-number\">2</span>\n}\n<span class=\"hljs-keyword\">const</span> { foo: renamedFoo } = myObject\nrenamedFoo <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Cette syntaxe est, il faut tout de même le noter, peu lisible.</p>\n<h3 id=\"arguments-de-fonctions\"><a class=\"markdownIt-Anchor\" href=\"#arguments-de-fonctions\">#</a> Arguments de fonctions</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// on peut directement utiliser le destructuring dans une déclaration de fonction</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">{ title, text }</span>) </span>{\n\t<span class=\"hljs-keyword\">return</span> title + <span class=\"hljs-string\">\": \"</span> + text\n}\n\nmyFunction({ title: <span class=\"hljs-string\">\"foo\"</span>, text: <span class=\"hljs-string\">\"bar\"</span> }) <span class=\"hljs-comment\">// \"foo: bar\"</span></code></pre>\n<h3 id=\"nested-destructuring\"><a class=\"markdownIt-Anchor\" href=\"#nested-destructuring\">#</a> Nested destructuring</h3>\n<p>On peut aussi “nester” les assignements.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> myObject = {\n  foo: {\n    bar: <span class=\"hljs-number\">1</span>,\n  },\n}\n<span class=\"hljs-keyword\">const</span> { foo: { bar } } = myObject\nbar <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Attention cependant, si le destructuring au premier niveau ne fera que retourner <code>undefined</code> si la valeur n’existe pas, vous aurez bel et bien une erreur avec le nesting, puisqu’il essaiera d’aller chercher une propriété d’<code>undefined</code>. Pour pallier ces soucis, rendez-vous pour l’article sur les <em>defaults</em>.</p>\n","rawBody":"\n## Le principe\n\nLe destructuring consiste à assigner des variables provenant d'un objet ou tableau en reposant sur leur structure.\n\n```javascript\n// partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// on peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n\n## Les différentes syntaxes\n\n### Tableau\n\n```javascript\n// pour un tableau, on utilise une forme proche de la déclaration litérale de tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Utiliser un nom différent de la clé\n\nPour un objet, par défaut, le nom de la variable correspond au nom de la clé. Si, par exemple, vous avez déjà une variable portant le nom de la clé dans le scope, vous pouvez choisir de nommer différemment votre variable.\n\n```javascript\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nCette syntaxe est, il faut tout de même le noter, peu lisible.\n\n### Arguments de fonctions\n\n```javascript\n// on peut directement utiliser le destructuring dans une déclaration de fonction\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nOn peut aussi \"nester\" les assignements.\n\n```javascript\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nAttention cependant, si le destructuring au premier niveau ne fera que retourner `undefined` si la valeur n'existe pas, vous aurez bel et bien une erreur avec le nesting, puisqu'il essaiera d'aller chercher une propriété d'`undefined`. Pour pallier ces soucis, rendez-vous pour l'article sur les *defaults*.\n","raw":"---\ndate: \"2015-12-02\"\ntitle: \"ES6, ES2015 : le destructuring\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - bloodyowl\n---\n\n## Le principe\n\nLe destructuring consiste à assigner des variables provenant d'un objet ou tableau en reposant sur leur structure.\n\n```javascript\n// partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// on peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n\n## Les différentes syntaxes\n\n### Tableau\n\n```javascript\n// pour un tableau, on utilise une forme proche de la déclaration litérale de tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Utiliser un nom différent de la clé\n\nPour un objet, par défaut, le nom de la variable correspond au nom de la clé. Si, par exemple, vous avez déjà une variable portant le nom de la clé dans le scope, vous pouvez choisir de nommer différemment votre variable.\n\n```javascript\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nCette syntaxe est, il faut tout de même le noter, peu lisible.\n\n### Arguments de fonctions\n\n```javascript\n// on peut directement utiliser le destructuring dans une déclaration de fonction\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nOn peut aussi \"nester\" les assignements.\n\n```javascript\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nAttention cependant, si le destructuring au premier niveau ne fera que retourner `undefined` si la valeur n'existe pas, vous aurez bel et bien une erreur avec le nesting, puisqu'il essaiera d'aller chercher une propriété d'`undefined`. Pour pallier ces soucis, rendez-vous pour l'article sur les *defaults*.\n","__filename":"fr/articles/js/es2015/destructuring.md","__url":"/fr/articles/js/es2015/destructuring/"}