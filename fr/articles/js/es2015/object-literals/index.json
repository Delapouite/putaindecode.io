{"head":{"layout":"Post","comments":true,"date":"2015-12-01","title":"ES6, ES2015 : Object literals","tags":["JavaScript","ES6","ES2015"],"authors":["lionelb"]},"body":"<p>Là encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l’initialisation d’objets.</p>\n<h2 id=\"nom-des-propri-t-s-raccourcies\"><a class=\"markdownIt-Anchor\" href=\"#nom-des-propri-t-s-raccourcies\">#</a> Nom des propriétés raccourcies</h2>\n<p>Lorsqu’on crée un objet, il arrive fréquemment que lorsqu’on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.</p>\n<pre><code><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> firstname</span> = <span class=\"hljs-string\">\"Robert\"</span>;\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> lastname</span> = <span class=\"hljs-string\">\"Laiponje\"</span>;\n\n<span class=\"hljs-keyword\">return</span> {\n  firstname: firstname,\n  lastname: lastname\n}</code></pre>\n<p>Avec ES2015, on va pouvoir l’écrire comme ça :</p>\n<pre><code><span class=\"hljs-keyword\">const</span> firstname = <span class=\"hljs-string\">\"Robert\"</span><span class=\"hljs-comment\">;</span>\n<span class=\"hljs-keyword\">const</span> lastname = <span class=\"hljs-string\">\"Laiponje\"</span><span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-keyword\">return</span> {\n  firstname, \n  lastname\n}\n// { firstname: <span class=\"hljs-string\">\"Robert\"</span>, lastname: <span class=\"hljs-string\">\"Laiponje\"</span> }</code></pre>\n<p>De la même manière, on pourra déclarer des méthodes en se passant du mot clé\n<code>function</code>. Idem pour les <em>getter</em> / <em>setter</em>.</p>\n<pre><code><span class=\"hljs-keyword\">const</span> obj = {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">email</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.email()\n  },\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">set</span> <span class=\"hljs-title\">email</span>(<span class=\"hljs-params\">email</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.email = email;\n  },\n  validateEmail(email) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n  }</code></pre>\n<h2 id=\"nom-de-propri-t-s-calcul-es\"><a class=\"markdownIt-Anchor\" href=\"#nom-de-propri-t-s-calcul-es\">#</a> Nom de propriétés calculées</h2>\n<p>La dernière nouveauté concernant les <em>literal objects</em> va nous permettre\nde créer des noms de propriétés depuis une expression, directement à la\ncréation de l’objet. Auparavant, il fallait procéder en 2 temps, création\npuis affectation.</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span> <span class=\"hljs-keyword\">action</span>(<span class=\"hljs-keyword\">type</span>, <span class=\"hljs-type\">data</span>) {\n  var  payload = {}\n  payload[<span class=\"hljs-keyword\">type</span>] = <span class=\"hljs-type\">data</span>;\n  <span class=\"hljs-keyword\">return</span> payload;\n}</code></pre>\n<p>En ES2015, cela donnerait :</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span> <span class=\"hljs-keyword\">action</span>(<span class=\"hljs-keyword\">type</span>, <span class=\"hljs-type\">data</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    [<span class=\"hljs-keyword\">type</span>]: payload\n  }\n}</code></pre>\n<p><strong>À noter</strong> qu’avec l’introduction des propriétés calculées, on va pouvoir\naussi déclarer plusieurs fois une même propriété, la dernière déclaration\nécrasant les précédentes (et plus de <code>syntaxError</code>).</p>\n","rawBody":"\nLà encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l'initialisation d'objets.\n\n## Nom des propriétés raccourcies\n\nLorsqu'on crée un objet, il arrive fréquemment que lorsqu'on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.\n\n```\nvar firstname = \"Robert\";\nvar lastname = \"Laiponje\";\n\nreturn {\n  firstname: firstname,\n  lastname: lastname\n}\n```\n\nAvec ES2015, on va pouvoir l'écrire comme ça :\n```\nconst firstname = \"Robert\";\nconst lastname = \"Laiponje\";\n\nreturn {\n  firstname, \n  lastname\n}\n// { firstname: \"Robert\", lastname: \"Laiponje\" }\n```\n\nDe la même manière, on pourra déclarer des méthodes en se passant du mot clé\n`function`. Idem pour les *getter* / *setter*.\n```\nconst obj = {\n  get email() {\n    return this.email()\n  },\n  set email(email) {\n    this.email = email;\n  },\n  validateEmail(email) {\n    return true;\n  }\n```\n\n## Nom de propriétés calculées\n\nLa dernière nouveauté concernant les *literal objects* va nous permettre \nde créer des noms de propriétés depuis une expression, directement à la \ncréation de l'objet. Auparavant, il fallait procéder en 2 temps, création \npuis affectation.\n\n```\nfunction action(type, data) {\n  var  payload = {}\n  payload[type] = data;\n  return payload;\n}\n```\nEn ES2015, cela donnerait :\n```\nfunction action(type, data) {\n  return {\n    [type]: payload\n  }\n}\n```\n**À noter** qu'avec l'introduction des propriétés calculées, on va pouvoir \naussi déclarer plusieurs fois une même propriété, la dernière déclaration \nécrasant les précédentes (et plus de `syntaxError`).\n","raw":"---\ndate: \"2015-12-01\"\ntitle: \"ES6, ES2015 : Object literals\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - lionelb\n---\n\nLà encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l'initialisation d'objets.\n\n## Nom des propriétés raccourcies\n\nLorsqu'on crée un objet, il arrive fréquemment que lorsqu'on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.\n\n```\nvar firstname = \"Robert\";\nvar lastname = \"Laiponje\";\n\nreturn {\n  firstname: firstname,\n  lastname: lastname\n}\n```\n\nAvec ES2015, on va pouvoir l'écrire comme ça :\n```\nconst firstname = \"Robert\";\nconst lastname = \"Laiponje\";\n\nreturn {\n  firstname, \n  lastname\n}\n// { firstname: \"Robert\", lastname: \"Laiponje\" }\n```\n\nDe la même manière, on pourra déclarer des méthodes en se passant du mot clé\n`function`. Idem pour les *getter* / *setter*.\n```\nconst obj = {\n  get email() {\n    return this.email()\n  },\n  set email(email) {\n    this.email = email;\n  },\n  validateEmail(email) {\n    return true;\n  }\n```\n\n## Nom de propriétés calculées\n\nLa dernière nouveauté concernant les *literal objects* va nous permettre \nde créer des noms de propriétés depuis une expression, directement à la \ncréation de l'objet. Auparavant, il fallait procéder en 2 temps, création \npuis affectation.\n\n```\nfunction action(type, data) {\n  var  payload = {}\n  payload[type] = data;\n  return payload;\n}\n```\nEn ES2015, cela donnerait :\n```\nfunction action(type, data) {\n  return {\n    [type]: payload\n  }\n}\n```\n**À noter** qu'avec l'introduction des propriétés calculées, on va pouvoir \naussi déclarer plusieurs fois une même propriété, la dernière déclaration \nécrasant les précédentes (et plus de `syntaxError`).\n","__filename":"fr/articles/js/es2015/object-literals.md","__url":"/fr/articles/js/es2015/object-literals/"}