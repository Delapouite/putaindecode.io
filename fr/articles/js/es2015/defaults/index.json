{"head":{"layout":"Post","comments":true},"body":"<p>Fatigués de taper <code>if (typeof x === 'undefined') x = defaultValue</code> ? Là encore\nES6 va nous apporter une solution élégante.</p>\n<h1 id=\"valeurs-par-d-faut\"><a class=\"markdownIt-Anchor\" href=\"#valeurs-par-d-faut\">#</a> Valeurs par défaut</h1>\n<p>L’opérateur <code>=</code> permet maintenant en plus d’affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.</p>\n<h2 id=\"param-tres-de-fonction\"><a class=\"markdownIt-Anchor\" href=\"#param-tres-de-fonction\">#</a> Paramètres de fonction</h2>\n<p>Il est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n’est pas fourni, ou qu’il\nest explicitement défini à <em>undefined</em>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incr</span> (<span class=\"hljs-params\">value, step = 1</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value + step\n}\n\nincr(<span class=\"hljs-number\">41</span>) <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">41</span>, <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">9</span>) <span class=\"hljs-comment\">// 42</span></code></pre>\n<h3 id=\"valeurs-par-d-faut-dynamiques\"><a class=\"markdownIt-Anchor\" href=\"#valeurs-par-d-faut-dynamiques\">#</a> Valeurs par défaut dynamiques</h3>\n<p>On peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée <strong>à l’appel de la fonction</strong>, pas lors de sa déclaration.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> defaultWho = <span class=\"hljs-string\">'world!'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hello</span> (<span class=\"hljs-params\">who = defaultWho.toUpperCase(</span>)) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello '</span> + who\n}\n\nhello() <span class=\"hljs-comment\">// 'Hello WORLD!'</span>\ndefaultWho = <span class=\"hljs-string\">'Anyone?'</span>\nhello() <span class=\"hljs-comment\">// 'Hello ANYONE?'</span></code></pre>\n<h3 id=\"r-utilisation-des-param-tres-pr-c-dents\"><a class=\"markdownIt-Anchor\" href=\"#r-utilisation-des-param-tres-pr-c-dents\">#</a> Réutilisation des paramètres précédents</h3>\n<p>Dans l’expression d’une valeur par défaut, on peut réutiliser les paramètres\n<strong>précédents</strong> de la fonction :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = 1, y = x + 1</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span> (<span class=\"hljs-params\">x = y + 1, y = 1</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y\n}\n\nfoo() <span class=\"hljs-comment\">// 1 + (1 + 1) → 3</span>\nbar() <span class=\"hljs-comment\">// (undefined + 1) + 1 → NaN</span></code></pre>\n<h3 id=\"cas-particulier-tdz-temporal-dead-zone\"><a class=\"markdownIt-Anchor\" href=\"#cas-particulier-tdz-temporal-dead-zone\">#</a> Cas particulier : TDZ (Temporal Dead Zone)</h3>\n<p>Une <em>temporal dead zone</em> désigne une zone du programme où une variable “existe”\nmais n’est pas encore accessible tant qu’elle n’a pas reçu de valeur.</p>\n<p>L’exemple suivant semble très logiquement invalide :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = x</span>) </span>{ <span class=\"hljs-comment\">// throws ReferenceError?</span>\n}</code></pre>\n<p>En effet, au moment de l’appel à la fonction, <code>x</code> n’a pas encore été défini,\net ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait <a href=\"http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters\">lever une erreur</a>.</p>\n<p>Néanmoins, les règles de portée font que ce programme est également invalide :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = x</span>) </span>{ <span class=\"hljs-comment\">// Le 'x' référencé ici est le paramètre</span>\n}</code></pre>\n<p>On est bien, dès l’évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope <code>x</code> fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.</p>\n<p><strong>#protip ne réutilisez pas 3 fois le même nom de variable</strong> (ça pourra aussi\naider à la compréhension)</p>\n<h2 id=\"d-composition\"><a class=\"markdownIt-Anchor\" href=\"#d-composition\">#</a> Décomposition</h2>\n<p>De la même manière que pour les paramètres de fonction, les affectations par\ndécomposition peuvent bénéficier de valeurs par défaut.</p>\n<pre><code class=\"language-js\">obj <span class=\"hljs-comment\">// {z: 42}</span>\n<span class=\"hljs-keyword\">const</span> { x = <span class=\"hljs-number\">1</span>, y = x + <span class=\"hljs-number\">1</span>, z, w } = obj\nw <span class=\"hljs-comment\">// undefined</span>\nx <span class=\"hljs-comment\">// 1</span>\ny <span class=\"hljs-comment\">// 2</span>\nz <span class=\"hljs-comment\">// 42</span></code></pre>\n<p>Pour rappel, l’affectation de l’exemple précédent aurait été écrit de cette\nmanière en ES5 :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> x = (obj.x === <span class=\"hljs-literal\">undefined</span>) ? obj.x : <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">var</span> y = (obj.y === <span class=\"hljs-literal\">undefined</span>) ? obj.y : x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">var</span> z = obj.z\n<span class=\"hljs-keyword\">var</span> w = obj.w</code></pre>\n<h1 id=\"enjoy\"><a class=\"markdownIt-Anchor\" href=\"#enjoy\">#</a> Enjoy!</h1>\n<p>Il n’y a <em>a priori</em> plus aucune raison de croiser un test sur <code>undefined</code> dans\nvotre code une fois passé à ES6.</p>\n<p>Un petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions. Il faudra donc utiliser Babel ou Traceur pour en profiter.</p>\n","rawBody":"\nFatigués de taper ``if (typeof x === 'undefined') x = defaultValue`` ? Là encore\nES6 va nous apporter une solution élégante.\n\n# Valeurs par défaut\n\nL'opérateur ``=`` permet maintenant en plus d'affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.\n\n## Paramètres de fonction\n\nIl est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n'est pas fourni, ou qu'il\nest explicitement défini à *undefined*.\n\n```js\nfunction incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n```\n\n### Valeurs par défaut dynamiques\n\nOn peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée **à l'appel de la fonction**, pas lors de sa déclaration.\n\n```js\nlet defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n```\n\n### Réutilisation des paramètres précédents\n\nDans l'expression d'une valeur par défaut, on peut réutiliser les paramètres\n**précédents** de la fonction :\n\n```js\nfunction foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n```\n\n### Cas particulier : TDZ (Temporal Dead Zone)\n\nUne *temporal dead zone* désigne une zone du programme où une variable \"existe\"\nmais n'est pas encore accessible tant qu'elle n'a pas reçu de valeur.\n\nL'exemple suivant semble très logiquement invalide :\n\n```js\nfunction foo (x = x) { // throws ReferenceError?\n}\n```\n\nEn effet, au moment de l'appel à la fonction, ``x`` n'a pas encore été défini,\net ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait [lever une erreur](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters).\n\nNéanmoins, les règles de portée font que ce programme est également invalide :\n\n```js\nconst x = 1\nfunction foo (x = x) { // Le 'x' référencé ici est le paramètre\n}\n```\n\nOn est bien, dès l'évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope ``x`` fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.\n\n**#protip ne réutilisez pas 3 fois le même nom de variable** (ça pourra aussi\naider à la compréhension)\n\n## Décomposition\n\nDe la même manière que pour les paramètres de fonction, les affectations par\ndécomposition peuvent bénéficier de valeurs par défaut.\n\n```js\nobj // {z: 42}\nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n```\n\nPour rappel, l'affectation de l'exemple précédent aurait été écrit de cette\nmanière en ES5 :\n\n```js\nvar x = (obj.x === undefined) ? obj.x : 1\nvar y = (obj.y === undefined) ? obj.y : x + 1\nvar z = obj.z\nvar w = obj.w\n```\n\n# Enjoy!\n\nIl n'y a *a priori* plus aucune raison de croiser un test sur ``undefined`` dans\nvotre code une fois passé à ES6.\n\nUn petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions. Il faudra donc utiliser Babel ou Traceur pour en profiter.\n","raw":"---\n  date: \"2015-12-03\"\n  title: \"ES6, ES2015 : valeurs par défaut des arguments\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - naholyr\n---\n\nFatigués de taper ``if (typeof x === 'undefined') x = defaultValue`` ? Là encore\nES6 va nous apporter une solution élégante.\n\n# Valeurs par défaut\n\nL'opérateur ``=`` permet maintenant en plus d'affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.\n\n## Paramètres de fonction\n\nIl est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n'est pas fourni, ou qu'il\nest explicitement défini à *undefined*.\n\n```js\nfunction incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n```\n\n### Valeurs par défaut dynamiques\n\nOn peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée **à l'appel de la fonction**, pas lors de sa déclaration.\n\n```js\nlet defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n```\n\n### Réutilisation des paramètres précédents\n\nDans l'expression d'une valeur par défaut, on peut réutiliser les paramètres\n**précédents** de la fonction :\n\n```js\nfunction foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n```\n\n### Cas particulier : TDZ (Temporal Dead Zone)\n\nUne *temporal dead zone* désigne une zone du programme où une variable \"existe\"\nmais n'est pas encore accessible tant qu'elle n'a pas reçu de valeur.\n\nL'exemple suivant semble très logiquement invalide :\n\n```js\nfunction foo (x = x) { // throws ReferenceError?\n}\n```\n\nEn effet, au moment de l'appel à la fonction, ``x`` n'a pas encore été défini,\net ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait [lever une erreur](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters).\n\nNéanmoins, les règles de portée font que ce programme est également invalide :\n\n```js\nconst x = 1\nfunction foo (x = x) { // Le 'x' référencé ici est le paramètre\n}\n```\n\nOn est bien, dès l'évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope ``x`` fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.\n\n**#protip ne réutilisez pas 3 fois le même nom de variable** (ça pourra aussi\naider à la compréhension)\n\n## Décomposition\n\nDe la même manière que pour les paramètres de fonction, les affectations par\ndécomposition peuvent bénéficier de valeurs par défaut.\n\n```js\nobj // {z: 42}\nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n```\n\nPour rappel, l'affectation de l'exemple précédent aurait été écrit de cette\nmanière en ES5 :\n\n```js\nvar x = (obj.x === undefined) ? obj.x : 1\nvar y = (obj.y === undefined) ? obj.y : x + 1\nvar z = obj.z\nvar w = obj.w\n```\n\n# Enjoy!\n\nIl n'y a *a priori* plus aucune raison de croiser un test sur ``undefined`` dans\nvotre code une fois passé à ES6.\n\nUn petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions. Il faudra donc utiliser Babel ou Traceur pour en profiter.\n","__filename":"fr/articles/js/es2015/defaults.md","__url":"/fr/articles/js/es2015/defaults/"}