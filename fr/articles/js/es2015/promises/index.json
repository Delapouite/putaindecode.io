{"head":{"layout":"Post","comments":true,"date":"2015-12-06","title":"ES6, ES2015 : les promises","tags":["JavaScript","ES6","ES2015"],"authors":["Uhsac"]},"body":"<p>ES2015 apporte une fonctionnalité simplifiant grandement l’asynchrone en\nJavaScript, les promises ! Visible depuis longtemps dans l’écosystème JavaScript\ngrâce a diverses librairies, on peut maintenant utiliser directement la\nspécification officielle.</p>\n<h2 id=\"c-est-quoi-une-promise\"><a class=\"markdownIt-Anchor\" href=\"#c-est-quoi-une-promise\">#</a> C’est quoi une promise ?</h2>\n<p>Une promise peut être vue comme la promesse d’une valeur non-disponible\nimmédiatement. Comme toute promesse, elle peut être tenue, la valeur est arrivée\net on peut s’en servir, ou ne pas l’être, dans ce cas une erreur arrive et on\npeut réagir en conséquence.</p>\n<p>Ce mécanisme permet de remplacer les callbacks d’une manière plus élégante. Au\nrevoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez\npas ? Voici un exemple pour vous le prouver :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// En utilisant les callbacks</span>\n<span class=\"hljs-comment\">// Imaginez que chacune de ces fonctions effectue des tâches asynchrones</span>\n<span class=\"hljs-comment\">// plus ou moins complexes (requête HTTP, appel à une base de données</span>\n<span class=\"hljs-comment\">// ou encore lecture de fichier)</span>\n<span class=\"hljs-keyword\">const</span> functionWithCallback1 = (callback) =&gt; callback(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback2 = (arg, callback) =&gt; callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback3 = (arg, callback) =&gt; callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback4 = (arg, callback) =&gt; callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback5 = (arg, callback) =&gt; callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback6 = (arg, callback) =&gt; callback(arg, <span class=\"hljs-literal\">undefined</span>)\n\nfunctionWithCallback1((result1, err) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    <span class=\"hljs-keyword\">throw</span> err\n  }\n  functionWithCallback2(result1, (result2, err) =&gt; {\n    <span class=\"hljs-keyword\">if</span> (err) {\n      <span class=\"hljs-keyword\">throw</span> err\n    }\n    functionWithCallback3(result2, (result3, err) =&gt; {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        <span class=\"hljs-keyword\">throw</span> err\n      }\n      functionWithCallback4(result3, (result4, err) =&gt; {\n        <span class=\"hljs-keyword\">if</span> (err) {\n          <span class=\"hljs-keyword\">throw</span> err\n        }\n        functionWithCallback5(result4, (result5, err) =&gt; {\n          <span class=\"hljs-keyword\">if</span> (err) {\n            <span class=\"hljs-keyword\">throw</span> err\n          }\n          functionWithCallback6(result5, (result6, err) =&gt; {\n            <span class=\"hljs-keyword\">if</span> (err) {\n              <span class=\"hljs-keyword\">throw</span> err\n            }\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Exemple avec les callback : <span class=\"hljs-subst\">${result6}</span>`</span>)\n          })\n        })\n      })\n    })\n  })\n})\n\n<span class=\"hljs-comment\">// Et maintenant, en utilisant les promises</span>\n<span class=\"hljs-keyword\">const</span> functionWithPromise1 = () =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'test'</span>)\n<span class=\"hljs-keyword\">const</span> functionWithPromise2 = (arg) =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise3 = (arg) =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise4 = (arg) =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise5 = (arg) =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise6 = (arg) =&gt; <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result =&gt; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Exemple avec les promises : <span class=\"hljs-subst\">${result}</span>`</span>))\n  .catch(err =&gt; {\n    <span class=\"hljs-keyword\">throw</span> err\n  })</code></pre>\n<p>Comme vous pouvez le voir, l’exemple avec les promises est tout de même plus\nlisible !</p>\n<h2 id=\"trop-bien-comment-je-les-utilise\"><a class=\"markdownIt-Anchor\" href=\"#trop-bien-comment-je-les-utilise\">#</a> Trop bien ! Comment je les utilise ?</h2>\n<p>Une promise peut avoir plusieurs états au cours de son existence :</p>\n<ul>\n<li>en cours : la valeur qu’elle contient n’est pas encore arrivée</li>\n<li>résolue : la valeur est arrivée, on peut l’utiliser</li>\n<li>rejetée : une erreur est survenue, on peut y réagir</li>\n</ul>\n<p>Une promise possède 2 fonctions : <code>then</code> et <code>catch</code>, vous pouvez utiliser <code>then</code>\npour récupérer le resultat ou l’erreur d’une promise et <code>catch</code> pour récupérer\nl’erreur d’une ou plusieurs promises.</p>\n<p>Voyons comment utiliser les promises à l’aide de la future implémentation de\n<a href=\"https://fetch.spec.whatwg.org\"><code>fetch</code></a>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// À ce moment, la promise est en attente</span>\n<span class=\"hljs-keyword\">const</span> fetchPromise = fetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n\n<span class=\"hljs-comment\">// Quand la requête est terminée la promise est résolue avec le résultat de</span>\n<span class=\"hljs-comment\">// la requête</span>\n<span class=\"hljs-keyword\">const</span> parsePromise = fetchPromise.then(fetchResult =&gt; {\n  <span class=\"hljs-comment\">// Je peux retourner une nouvelle promise à partir d'un then, ici</span>\n  <span class=\"hljs-comment\">// j'appelle .text() qui parse le contenu de la requête et retourne</span>\n  <span class=\"hljs-comment\">// une promise</span>\n  <span class=\"hljs-keyword\">return</span> fetchResult.text()\n})\n\n<span class=\"hljs-comment\">// Quand le parsing est terminé, je peux recuperer son contenu</span>\nparsePromise.then(textResult =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n})\n\n<span class=\"hljs-comment\">// Si la requête a un problème, la promise est rejetée avec une erreur</span>\nfetchPromise.catch(fetchError =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête\"</span>, fetchError)\n})\n\n<span class=\"hljs-comment\">// S'il y a une erreur pendant le parsing, je peux la récupérer</span>\nparsePromise.catch(parseError =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant le parsing\"</span>, parseError)\n})\n\n<span class=\"hljs-comment\">// Cela peut aussi être écrit</span>\nfetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n  .then(fetchResult =&gt; fetchResult.text())\n  .then(textResult =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n  })\n  .catch(error =&gt; {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête ou le parsing\"</span>, fetchError)\n  })\n\n<span class=\"hljs-comment\">// Ou encore</span>\nfetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n  .then(\n    fetchResult =&gt; {\n      <span class=\"hljs-keyword\">return</span> fetchResult.text()\n    },\n    fetchError =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête\"</span>, fetchError)\n    }\n  )\n  .then(\n    textResult =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n    },\n    parseError =&gt; {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant le parsing\"</span>, parseError)\n    }\n  )</code></pre>\n<h2 id=\"mais-comment-je-cr-e-mes-propres-promises\"><a class=\"markdownIt-Anchor\" href=\"#mais-comment-je-cr-e-mes-propres-promises\">#</a> Mais comment je crée mes propres promises ?</h2>\n<p>C’est bien beau d’utiliser les promises, mais c’est encore mieux de savoir créer\nles vôtres ! Je vous rassure, c’est très simple.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> functionThatReturnAPromise = (success) =&gt; {\n  <span class=\"hljs-comment\">// On utilise la classe Promise pour en créer une, le constructeur prend 2</span>\n  <span class=\"hljs-comment\">// fonctions en paramètre :</span>\n  <span class=\"hljs-comment\">// - resolve que l'on pourra appeler avec le résultat de notre fonction</span>\n  <span class=\"hljs-comment\">// - reject que l'on pourra appeler avec une erreur s'il y a une erreur</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>((resolve, reject) =&gt; {\n    <span class=\"hljs-keyword\">if</span> (success) {\n      resolve(<span class=\"hljs-string\">'success'</span>)\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      reject(<span class=\"hljs-string\">'failed'</span>)\n    }\n  })\n}\n\n<span class=\"hljs-comment\">// Vous pouvez maintenant utiliser votre fonction comme vu précédemment</span>\nfunctionThatReturnAPromise(success)\n  .then(res =&gt; <span class=\"hljs-built_in\">console</span>.log(res))\n  .catch(error =&gt; <span class=\"hljs-built_in\">console</span>.log(error))\n\n<span class=\"hljs-comment\">// équivalent dans notre cas à</span>\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) =&gt; <span class=\"hljs-built_in\">console</span>.log(res),\n    (error) =&gt; <span class=\"hljs-built_in\">console</span>.log(error)\n  )</code></pre>\n<h2 id=\"et-demain\"><a class=\"markdownIt-Anchor\" href=\"#et-demain\">#</a> Et demain ?</h2>\n<p>Une fonctionnalité encore plus pratique que les promises arrive en JavaScript,\nles mots-clés <code>async</code> et <code>await</code> ! Ces mots-clés vous permettront d’avoir un code\nencore plus lisible quand vous ferez de l’asynchrone, mais ça ne concerne pas\nES2015 :)</p>\n","rawBody":"\nES2015 apporte une fonctionnalité simplifiant grandement l'asynchrone en\nJavaScript, les promises ! Visible depuis longtemps dans l'écosystème JavaScript\ngrâce a diverses librairies, on peut maintenant utiliser directement la\nspécification officielle.\n\n## C'est quoi une promise ?\n\nUne promise peut être vue comme la promesse d'une valeur non-disponible\nimmédiatement. Comme toute promesse, elle peut être tenue, la valeur est arrivée\net on peut s'en servir, ou ne pas l'être, dans ce cas une erreur arrive et on\npeut réagir en conséquence.\n\nCe mécanisme permet de remplacer les callbacks d'une manière plus élégante. Au\nrevoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez\npas ? Voici un exemple pour vous le prouver :\n\n```js\n// En utilisant les callbacks\n// Imaginez que chacune de ces fonctions effectue des tâches asynchrones\n// plus ou moins complexes (requête HTTP, appel à une base de données\n// ou encore lecture de fichier)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Exemple avec les callback : ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Et maintenant, en utilisant les promises\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Exemple avec les promises : ${result}`))\n  .catch(err => {\n    throw err\n  })\n```\n\nComme vous pouvez le voir, l'exemple avec les promises est tout de même plus\nlisible !\n\n## Trop bien ! Comment je les utilise ?\n\nUne promise peut avoir plusieurs états au cours de son existence :\n- en cours : la valeur qu'elle contient n'est pas encore arrivée\n- résolue : la valeur est arrivée, on peut l'utiliser\n- rejetée : une erreur est survenue, on peut y réagir\n\nUne promise possède 2 fonctions : `then` et `catch`, vous pouvez utiliser `then`\npour récupérer le resultat ou l'erreur d'une promise et `catch` pour récupérer\nl'erreur d'une ou plusieurs promises.\n\nVoyons comment utiliser les promises à l'aide de la future implémentation de\n[`fetch`](https://fetch.spec.whatwg.org).\n\n```js\n// À ce moment, la promise est en attente\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// Quand la requête est terminée la promise est résolue avec le résultat de\n// la requête\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // Je peux retourner une nouvelle promise à partir d'un then, ici\n  // j'appelle .text() qui parse le contenu de la requête et retourne\n  // une promise\n  return fetchResult.text()\n})\n\n// Quand le parsing est terminé, je peux recuperer son contenu\nparsePromise.then(textResult => {\n  console.log(`Voici le résultat : ${textResult}`)\n})\n\n// Si la requête a un problème, la promise est rejetée avec une erreur\nfetchPromise.catch(fetchError => {\n  console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n})\n\n// S'il y a une erreur pendant le parsing, je peux la récupérer\nparsePromise.catch(parseError => {\n  console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n})\n\n// Cela peut aussi être écrit\nfetch('http://putaindecode.io')\n  .then(fetchResult => fetchResult.text())\n  .then(textResult => {\n    console.log(`Voici le résultat : ${textResult}`)\n  })\n  .catch(error => {\n    console.log(\"Une erreur a eu lieu pendant la requête ou le parsing\", fetchError)\n  })\n\n// Ou encore\nfetch('http://putaindecode.io')\n  .then(\n    fetchResult => {\n      return fetchResult.text()\n    },\n    fetchError => {\n      console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n    }\n  )\n  .then(\n    textResult => {\n      console.log(`Voici le résultat : ${textResult}`)\n    },\n    parseError => {\n      console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n    }\n  )\n```\n\n## Mais comment je crée mes propres promises ?\n\nC'est bien beau d'utiliser les promises, mais c'est encore mieux de savoir créer\nles vôtres ! Je vous rassure, c'est très simple.\n\n```js\nconst functionThatReturnAPromise = (success) => {\n  // On utilise la classe Promise pour en créer une, le constructeur prend 2\n  // fonctions en paramètre :\n  // - resolve que l'on pourra appeler avec le résultat de notre fonction\n  // - reject que l'on pourra appeler avec une erreur s'il y a une erreur\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// Vous pouvez maintenant utiliser votre fonction comme vu précédemment\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// équivalent dans notre cas à\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n```\n\n## Et demain ?\n\nUne fonctionnalité encore plus pratique que les promises arrive en JavaScript,\nles mots-clés `async` et `await` ! Ces mots-clés vous permettront d'avoir un code\nencore plus lisible quand vous ferez de l'asynchrone, mais ça ne concerne pas\nES2015 :)\n","raw":"---\ndate: \"2015-12-06\"\ntitle: \"ES6, ES2015 : les promises\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - Uhsac\n---\n\nES2015 apporte une fonctionnalité simplifiant grandement l'asynchrone en\nJavaScript, les promises ! Visible depuis longtemps dans l'écosystème JavaScript\ngrâce a diverses librairies, on peut maintenant utiliser directement la\nspécification officielle.\n\n## C'est quoi une promise ?\n\nUne promise peut être vue comme la promesse d'une valeur non-disponible\nimmédiatement. Comme toute promesse, elle peut être tenue, la valeur est arrivée\net on peut s'en servir, ou ne pas l'être, dans ce cas une erreur arrive et on\npeut réagir en conséquence.\n\nCe mécanisme permet de remplacer les callbacks d'une manière plus élégante. Au\nrevoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez\npas ? Voici un exemple pour vous le prouver :\n\n```js\n// En utilisant les callbacks\n// Imaginez que chacune de ces fonctions effectue des tâches asynchrones\n// plus ou moins complexes (requête HTTP, appel à une base de données\n// ou encore lecture de fichier)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Exemple avec les callback : ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Et maintenant, en utilisant les promises\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Exemple avec les promises : ${result}`))\n  .catch(err => {\n    throw err\n  })\n```\n\nComme vous pouvez le voir, l'exemple avec les promises est tout de même plus\nlisible !\n\n## Trop bien ! Comment je les utilise ?\n\nUne promise peut avoir plusieurs états au cours de son existence :\n- en cours : la valeur qu'elle contient n'est pas encore arrivée\n- résolue : la valeur est arrivée, on peut l'utiliser\n- rejetée : une erreur est survenue, on peut y réagir\n\nUne promise possède 2 fonctions : `then` et `catch`, vous pouvez utiliser `then`\npour récupérer le resultat ou l'erreur d'une promise et `catch` pour récupérer\nl'erreur d'une ou plusieurs promises.\n\nVoyons comment utiliser les promises à l'aide de la future implémentation de\n[`fetch`](https://fetch.spec.whatwg.org).\n\n```js\n// À ce moment, la promise est en attente\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// Quand la requête est terminée la promise est résolue avec le résultat de\n// la requête\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // Je peux retourner une nouvelle promise à partir d'un then, ici\n  // j'appelle .text() qui parse le contenu de la requête et retourne\n  // une promise\n  return fetchResult.text()\n})\n\n// Quand le parsing est terminé, je peux recuperer son contenu\nparsePromise.then(textResult => {\n  console.log(`Voici le résultat : ${textResult}`)\n})\n\n// Si la requête a un problème, la promise est rejetée avec une erreur\nfetchPromise.catch(fetchError => {\n  console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n})\n\n// S'il y a une erreur pendant le parsing, je peux la récupérer\nparsePromise.catch(parseError => {\n  console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n})\n\n// Cela peut aussi être écrit\nfetch('http://putaindecode.io')\n  .then(fetchResult => fetchResult.text())\n  .then(textResult => {\n    console.log(`Voici le résultat : ${textResult}`)\n  })\n  .catch(error => {\n    console.log(\"Une erreur a eu lieu pendant la requête ou le parsing\", fetchError)\n  })\n\n// Ou encore\nfetch('http://putaindecode.io')\n  .then(\n    fetchResult => {\n      return fetchResult.text()\n    },\n    fetchError => {\n      console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n    }\n  )\n  .then(\n    textResult => {\n      console.log(`Voici le résultat : ${textResult}`)\n    },\n    parseError => {\n      console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n    }\n  )\n```\n\n## Mais comment je crée mes propres promises ?\n\nC'est bien beau d'utiliser les promises, mais c'est encore mieux de savoir créer\nles vôtres ! Je vous rassure, c'est très simple.\n\n```js\nconst functionThatReturnAPromise = (success) => {\n  // On utilise la classe Promise pour en créer une, le constructeur prend 2\n  // fonctions en paramètre :\n  // - resolve que l'on pourra appeler avec le résultat de notre fonction\n  // - reject que l'on pourra appeler avec une erreur s'il y a une erreur\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// Vous pouvez maintenant utiliser votre fonction comme vu précédemment\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// équivalent dans notre cas à\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n```\n\n## Et demain ?\n\nUne fonctionnalité encore plus pratique que les promises arrive en JavaScript,\nles mots-clés `async` et `await` ! Ces mots-clés vous permettront d'avoir un code\nencore plus lisible quand vous ferez de l'asynchrone, mais ça ne concerne pas\nES2015 :)\n","__filename":"fr/articles/js/es2015/promises.md","__url":"/fr/articles/js/es2015/promises/"}